###
类和它们的实例通常是一对多的关系.然而有一些类,它们应该只有一个实例.这个实例似乎应当在程序启动时被创建
出来,并且只在程序结束时才被删除.有时,这种对象是应用程序的基础对象.有时,它们是工厂对象,用于创建系统中
的其他对象.有时,这些对象是管理器对象,负责管理某些其他对象并以合适的方式去控制它们.  
那些强制对象单一性的机制似乎有点多余.毕竟,在初始化应用程序时,完全可以只创建每个对象的一个实例,然后
使用该实例.事实上,这通常是最好的办法.在没有急迫并且有意义的需要时,应该避免使用这些机制.如果强制对象
单一性的机制是轻量级,那么传达意图带来的收益就会胜过实施这些机制的代价.  
#### 16.1 Singleton模式
Singleton是一个很简单的模式.下面程序的测试用例演示了它应该如何工作.第一个测试函数表明了Singleton实例
是通过公有静态方法instance访问的.它同样也表明了即使instance方法被多次调用,每次返回的都是指向完全相同
实例的引用.第二个测试用例表示Singleton类没有公有构造函数,所以如果不适用instance方法,就无法创建它的实例.  
Singleton.j  
TestSimpleSingleton.j  
#### 16.1.1 Singleton模式的好处
1. 跨平台: 使用合适的中间件,可以把Singleton模式扩展为跨多个JVM和多个计算机工作.
2. 适用于任何类: 只需把一个类的构造函数变为私有的,并且在其中增加相应的静态函数和变量,就可以把这个类
变成Singleton.
3. 可以透过派生创建: 给定一个类,可以创建它的一个Singleton子类.
4. 延迟求值(Lazy evaluation): 如果Singleton从未使用过,那么就绝不会创建它.
#### 16.1.2 Singleton模式的代价
1. 摧毁方法未定义: 没有好的方法去摧毁一个Singleton,或解除其职责.
2. 不能继承: 从Singleton派生出的类并不是Singleton.
3. 效率问题: 每次调用instance方法都会执行if语句.绝大数调用而言,if语句是多余的.  
4. 不透明性: Singleton的使用者知道它们正在使用一个Singleton,因为它们必须要调用instance方法.
#### 16.1.3 运用Singleton模式
基本Web的系统,它允许用户登录进入受保护的区域.这样的系统会有一个包含用户名、口令以及其他用户属性的数据
库.假设这个数据库通过第三方API进行访问.可以在每个需要读写用户信息的模块中直接访问数据库.然而,这样会
使得对第三方API的使用分散在整个代码中,并且也无法去强制实施一些访问或者结构方面的约定.  
一个比较好的解决方案是运用facade模式创建UserDatabase类,该类中包含有读写User对象的方法.这些方法调用
访问数据库的第三方API,并执行User对象和数据库的表、行之间的转换工作.在UserDatabase类中,我们可以强制
实施访问和结构方面的约定.例如,可以保证一条User记录除非拥有非空的username,否则不予写入数据库.或者还
可以把对同一条User的访问串行化,确保两个模块不会同时去读写它.  
下面程序展示了Singleton模式的解决方案.Singleton类的名字是UserDatabaseSource.它实现了UserDatabase
接口.请注意静态方法instance()并没有像惯常的那样用if语句来避免多次创建,而利用Java语言初始化功能.  
usage.p  
这是Singleton模式的常见应用.确保了所有对数据库访问都通过这个Singleton.可以容易地在UseDatabaseSource
类中放入检查、计数、锁等机制来实现想要的功能.  
#### 16.2 Monostate模式
Monostate模式是获取对象单一性的方法.使用完全不同的工作机制.  
一个关注行为,另一个关注结构.Singleton模式强制结构上的单一性,它防止创建出多个对象实例.相反,Monostate
模式则强制行为上的单一性,而没有强加结构方面的限制.Monostate的测试用例对Singleton是有效的,但是Singleton
的测试用例却远不适用于Monostate类.
#### 16.2.1 Monostate模式的好处
1. 透明性:使用Monostate对象和使用常规对象没什么区别.使用者不需要知道对象是monostate.
2. 可派生性: Monostate派生类都是Monostate
3. 多态性: 由于Monostate的方法不是静态的,可以在派生类中覆写它.
#### 16.2.2 Monostate模式的代价
1. 不可转换性: 不能透过派生把常规类转换成Monostate类.
2. 效率问题: 因为Monostate是真正的对象,所以会导致许多的创建和摧毁开销.
3. 内存占用: 即使未使用,它的变量也要占据内存空间.
4. 平台局限性: Monostate不能跨多个JVM
#### 16.2.3 运用Monostate模式
monostate.p  
其中利用Monostate的派生对象具有多态的能力以及这些派生对象本身也是monostate的事实.  
让Unlocked和Locked从Turnstile派生似乎违反了常规的面向对象原则.不过,由于Turnstile是一个Monostate,
所以实例之间没有区别.这样,Unlocked和Locked实际上也不是不同对象.相反,它们是Turnstile抽象的一部分.
Unlocked,Locked,以及Turnstile访问是相同的变量和方法.
#### 16.3 结论
Singleton模式私有构造函数,一个静态变量,以及一个静态方法对实例化进行控制和限制.Monostate模式只是简单
地把对象的所有变量变成静态的.  
如果希望通过派生去约束现存类,并且不介意必须调用instance()方法,那么Singleton是最合适的.如果希望类的
单一性本质对使用者透明,或者希望使用单一对象的多态派生对象,那么Monostate是最合适的.
