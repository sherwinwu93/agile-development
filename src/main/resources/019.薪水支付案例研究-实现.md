###
很早以前,我们就编写了支持和验证前面所讲述的设计的代码.本章中,我会以微小增量的方法来创建该代码,但是
只在文中适当的地方才展示它.文中,你只会看到完整形式的代码快照,请不要被其误导认为代码就是以那种形式
编写的.事实上,在你所看见的每块代码之间,都有许多的编辑、编译和测试用例,它们都对代码进行了微小的改进.

同样,你也会看到相当多的UML图.请把这些UML图看作是我快速在白板上勾画的草图,用来向你展示我的想法.UML
为你我之间的交流提供了方便的媒介.

图19.1显示出我们用一个名为Transaction的抽象基类来代表操作,该类具有一个名为execute()的实例方法.这
当然是Command模式.Transaction类的实现如Transaction.j  
Transaction.j

#### 19.1 增加雇员
图19.2展示了一个增加雇员操作的可能结构.请注意,正式这些操作把雇员的支付薪水时间表和他们的支付薪水类
别关联起来.这样做是合适的,因为这些操作是人工发明物而不是核心模型的一部分.所以,核心模型不会察觉到关
联;关联只是我们附加上去的内容,并且可以随时更改.例如:可以容易地增加一种更改雇员支付薪水时间表的操作.

19.2.AddEmployeeTranaction的静态模型.v

同样请注意,缺省的支付方式是由出纳人员保存支付支票.如果雇员希望采用另一种支付方式,就必须要使用适当
的chgEmp操作进行更改.

如往常一样,我们使用测试优先的方法来编写代码.PayrollTest是一个测试用例,用来证明addSalariedTransaction
可以正确地工作.随后的代码将会通过该测试用例.

#### 19.1.1 薪水支付系统数据库
AddEmployeeTransaction类使用了一个名为PayrollDatabase的类.PayrollDatabase类在一个以empId为键值的
Map中保存着全部现有的Employee对象.同时,它也持有一个把协会的memberId映射为empId的Map.图19.3中展示
了该类的结构.PayrollDatabase是一个Facade模式的例子.

程序PayrollDatabase展示了PayrollDatabaseImpl类的初步实现.该实现是为了帮助通过最初的测试用例.它还没有
包含把协会会员id映射为Employee实例的Map对象.

一般而言,我认为数据库是实现细节.应该尽可能地推迟有关这些细节的决策.不管这个特定的数据库是RDBMS、平
面文件(flat file)或者OODBMS实现的.此时都是无关紧要的.现在,我仅仅对创建为应用程序的其他部分提供数据
库服务的API感兴趣.随后,我会发现有关数据库的合适实现.

推迟有关数据库的细节是一项不常见、但却很值得的实践.我们常常会一直等到对软件及其需要有了更多的知识时,
才进行有关数据库的决策.通过等待,我们避免了把过多的基础结构放入数据库中的问题.我们更愿意仅仅实现刚好
满足应用程序需要的数据库功能.

#### 19.1.2 使用Template Method模式来增加雇员
图19.4展示了增加雇员的动态模型,为了得到正确的PaymentClassification对象和PaymentSchedule对象,请注
意AddEmployeeTransaction对象向自己发送了一个消息.AddEmployeeTransaction类的派生类实现了这些消息.
这是一个Temple Method模式的应用.

程序AddEmployeeTransaction和程序AddEmployeeTransactionImpl中展示了AddEmployeeTransaction类中
Template Method 模式的实现.该类的execute()方法中调用了两个会派生类中实现的纯虚函数.getSchedule()
和getClassification()这两个函数返回新创建的Employee对象所需要的PaymentSchedule和Payment-
Classification对象.接着,execute()方法把这些对象绑定到Employee对象上并把Employee对象存入Payroll-
Database中.

AddEmployeeTransaction.j  
AddEmployeeTransactionImpl.j  

程序AddSalariedEmployee和程序AddSalariedEmployeeImpl展示了AddSalariedEmployee的实现.该类派生自
AddEmployeeTransaction类并在getSchedule()方法和getClassification()方法的实现中传回合适的对象给
AddEmployeeTransaction.execute().

AddSalariedEmployee.j  
AddSalariedEmployeeImpl.j

#### 19.2 删除雇员
图19.5和图19.6中展现了删除雇员操作的静态和动态模型.

程序中PayrollTest展示了删除雇员的测试用例.程序和程序展示了deleteEmployeeTransaction的实现.这是一个非常典型的
Command模式的实现.构造函数保存了execute()方法最后会使用的数据.  
19.5.DeleteEmployee操作的静态模型.v  
19.6.DeleteEmployee操作的动态模型.v

#### 19.2.1 全局变量
此时,你已经注意到了GpayrollDatabas全局变量.数十年来,教科书和教师一直都有好的理由不鼓励使用全局变量.
然而,全局变量并非本质上就是邪恶和有害的.在本案例中,全局变量就是理想选择.PayrollDatabase类始终只有
一个实例,并且该实例需要在一个很广泛的范围中使用.

也许你会认为使用Singleton模式和monostate模式可以更好地达到这个目的.这些模式确实可以达到目的.不过,它
们是通过自身使用全局变量来到达这个目的的.Singleton和Monostate本来就是全局实体.在本例中,使用Singleton
模式或者monostate模式具有不必要的复杂性的臭味.简单地把数据库实例保存在一个全局变量中会更容易一些.

#### 19.3 时间卡、销售凭条以及服务费用
图19.7中展示了向雇员中登记时间卡操作的静态结构.图19.8中展示了该操作的动态模型.基本思路是,该操作从
PayrollDatabase中得到Employee对象,向Employee对象请求它的PaymentClassification对象,然后创建一个
TimeCard对象并把该对象增加到PaymentClassification中.

注意,不能把TimeCard对象增加到一般的PayClassification对象中,只能增加到HourlyClassification中.意味
着必须把Employee获取的PaymentClassification对象向下转型为HourlyClassification.如TimeCard-
TransactionImpl.

PayrollTest.timeCardTransaction是测试用例,测试验证向钟点工加入时间卡.代码是创建钟点工加入数据库.
接着,创建TimeCardTransaction并调用execute().然后,检查HourlyClassification包含适当的TimeCard

TimeCard只是数据类,用了长整数表示日期.因为没有便于使用的Date类.也许很快就要一个,但是现在不需要.
我向专注于手边的工作.通过当前测试用例.最后,会编写一个需要真正Date类的测试用例.到那时,会回来更新
TimeCard类.

程序TimeCardTransaction和TimeCardTransactionImpl.注意,其中使用简单的自负床异常.这不是好的长期实
践,但是足以满足初期需求.在实际需要的异常有了解后,再回来创建有意义的异常类.

图19.9和图19.10展示了向应支付薪水的雇员中登记销售凭条操作的设计.

图19.11和图19.12展示向协会成员登记服务费用操作的设计.

这些设计指出操作模型和已创建的核心模型间的适配.核心Employee对象可以和许多不同组织间有从属关系,但是
操作模型却假定所有从属关系都是协会从属关系.因此,操作模型就无法识别从属关系的明确种类.相反,它只是假定
如果向雇员中登记了服务费用,那么该雇员就具有协会从属关系.

动态模型解决了这个两难问题.它再Employee对象中包含了一组Affiliation对象中搜寻UnionAffiliation对象.
然后,把ServiceCharge增加到搜寻到的UnionAffiliation对象中.

PayrollTest.addServiceCharge().简单地创建钟点雇员对象并向其中增加一个UnionAffiliation.同时,也确
保向PayrollDatabase中注册了适当的协会成员id.接着,创建一个ServiceChargeTransaction并执行之.最后,
证明ServiceCharge确实被加入到Employee的UnionAffiliation中.

#### 19.3.1 代码与UML
在画19.12时,用从属关系对象取代NoAffiliation是更好的设计.这样更灵活点.然而,在编写程序PayrollTest.
addServiceCharge()时,我认识到调用Employee的setAffiliation要比调用addAffiliation更好一些.毕竟,
需求并没有要求雇员有多个Affiliation.所以没有必要使用强转中选择.如果这些做会带来不必要的复杂性.

这个例子说明画太多的UML图而没有验证代码是危险的.这里,我在UML中就放入一些不需要的结构.也许,这些
结构总有一天会派上用途.但是必须维护他们,抵不上维护的代价.

如果不使用Affiliation对象列表,实现起来会简单很多.会继续保持Null Object模式以及NoAffiliation类.

ServiceChargeTransaction.没有了搜寻UnionAffiliation对象的循环,该类确实简单不少,简单地从数据库
中获取Employee对象,把该对象的Affiliation向下转型为UnionAffiliation,接着把ServiceCharge加入其中.

#### 19.4 更改雇员属性
图19.13和19.14展示了更改雇员属性操作的静态结构.从用例6很容易得到这个结构.因为所有的操作都以empId
作为参数,所以创建更高的基类ChangeEmployeeTransaction.该基类的下面一层是修改单个属性的类,比如:
ChangeNameTransaction和ChangeAddressTransaction.改变雇员类别的操作有共同的行为,都会修改Employee
对象的同一个字段.因此,可以把它们放在抽象基类ChangeClassificationTransaction之下.更改支付方式和
从属关系的操作与此雷同.从ChangeMethodTransaction类和ChangeAffiliationTransaction类的结构中可以看
到这一点.

图19.15展示了所有更改操作的动态模型.其中再次使用Template Method模式.对于所有的更改操作,都必须要
从PayrollDatabase中去除对应于EmpId的Employee对象.因此,ChangeEmployeeTransaction的execute()实现
了这个行为,然后给自己发送Change消息.Change方法被声明为虚的并在派生类中实现.如图19.16和图19.17所示.

PayrollTest.changeNameTransaction()展示了ChangeNameTransaction的测试用例.它使用AddHourlyEmployee
操作创建了名为Bill的钟点工.接着,创建并执行ChangeNameTransaction操作,该操作把雇员名字更改为Bob.
最后,从PayrollDatabase中去除该雇员实例并验证名字已经被更改.

