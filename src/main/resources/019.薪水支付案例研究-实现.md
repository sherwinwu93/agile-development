###
很早以前,我们就编写了支持和验证前面所讲述的设计的代码.本章中,我会以微小增量的方法来创建该代码,但是
只在文中适当的地方才展示它.文中,你只会看到完整形式的代码快照,请不要被其误导认为代码就是以那种形式
编写的.事实上,在你所看见的每块代码之间,都有许多的编辑、编译和测试用例,它们都对代码进行了微小的改进.

同样,你也会看到相当多的UML图.请把这些UML图看作是我快速在白板上勾画的草图,用来向你展示我的想法.UML
为你我之间的交流提供了方便的媒介.

图19.1显示出我们用一个名为Transaction的抽象基类来代表操作,该类具有一个名为execute()的实例方法.这
当然是Command模式.Transaction类的实现如Transaction.j  
Transaction.j

#### 19.1 增加雇员
图19.2展示了一个增加雇员操作的可能结构.请注意,正式这些操作把雇员的支付薪水时间表和他们的支付薪水类
别关联起来.这样做是合适的,因为这些操作是人工发明物而不是核心模型的一部分.所以,核心模型不会察觉到关
联;关联只是我们附加上去的内容,并且可以随时更改.例如:可以容易地增加一种更改雇员支付薪水时间表的操作.

19.2.AddEmployeeTranaction的静态模型.v

同样请注意,缺省的支付方式是由出纳人员保存支付支票.如果雇员希望采用另一种支付方式,就必须要使用适当
的chgEmp操作进行更改.

如往常一样,我们使用测试优先的方法来编写代码.PayrollTest是一个测试用例,用来证明addSalariedTransaction
可以正确地工作.随后的代码将会通过该测试用例.

#### 19.1.1 薪水支付系统数据库
AddEmployeeTransaction类使用了一个名为PayrollDatabase的类.PayrollDatabase类在一个以empId为键值的
Map中保存着全部现有的Employee对象.同时,它也持有一个把协会的memberId映射为empId的Map.图19.3中展示
了该类的结构.PayrollDatabase是一个Facade模式的例子.

程序PayrollDatabase展示了PayrollDatabaseImpl类的初步实现.该实现是为了帮助通过最初的测试用例.它还没有
包含把协会会员id映射为Employee实例的Map对象.

一般而言,我认为数据库是实现细节.应该尽可能地推迟有关这些细节的决策.不管这个特定的数据库是RDBMS、平
面文件(flat file)或者OODBMS实现的.此时都是无关紧要的.现在,我仅仅对创建为应用程序的其他部分提供数据
库服务的API感兴趣.随后,我会发现有关数据库的合适实现.

推迟有关数据库的细节是一项不常见、但却很值得的实践.我们常常会一直等到对软件及其需要有了更多的知识时,
才进行有关数据库的决策.通过等待,我们避免了把过多的基础结构放入数据库中的问题.我们更愿意仅仅实现刚好
满足应用程序需要的数据库功能.

#### 19.1.2 使用Template Method模式来增加雇员
图19.4展示了增加雇员的动态模型,为了得到正确的PaymentClassification对象和PaymentSchedule对象,请注
意AddEmployeeTransaction对象向自己发送了一个消息.AddEmployeeTransaction类的派生类实现了这些消息.
这是一个Temple Method模式的应用.

程序AddEmployeeTransaction和程序AddEmployeeTransactionImpl中展示了AddEmployeeTransaction类中
Template Method 模式的实现.该类的execute()方法中调用了两个会派生类中实现的纯虚函数.getSchedule()
和getClassification()这两个函数返回新创建的Employee对象所需要的PaymentSchedule和Payment-
Classification对象.接着,execute()方法把这些对象绑定到Employee对象上并把Employee对象存入Payroll-
Database中.

AddEmployeeTransaction.j  
AddEmployeeTransactionImpl.j  

程序AddSalariedEmployee和程序AddSalariedEmployeeImpl展示了AddSalariedEmployee的实现.该类派生自
AddEmployeeTransaction类并在getSchedule()方法和getClassification()方法的实现中传回合适的对象给
AddEmployeeTransaction.execute().

AddSalariedEmployee.j  
AddSalariedEmployeeImpl.j

#### 19.2 删除雇员
图19.5和图19.6中展现了删除雇员操作的静态和动态模型.

程序中PayrollTest展示了删除雇员的测试用例.程序和程序展示了deleteEmployeeTransaction的实现.这是一个非常典型的
Command模式的实现.构造函数保存了execute()方法最后会使用的数据.  
19.5.DeleteEmployee操作的静态模型.v  
19.6.DeleteEmployee操作的动态模型.v

#### 19.2.1 全局变量
此时,你已经注意到了GpayrollDatabas全局变量.数十年来,教科书和教师一直都有好的理由不鼓励使用全局变量.
然而,全局变量并非本质上就是邪恶和有害的.在本案例中,全局变量就是理想选择.PayrollDatabase类始终只有
一个实例,并且该实例需要在一个很广泛的范围中使用.

也许你会认为使用Singleton模式和monostate模式可以更好地达到这个目的.这些模式确实可以达到目的.不过,它
们是通过自身使用全局变量来到达这个目的的.Singleton和Monostate本来就是全局实体.在本例中,使用Singleton
模式或者monostate模式具有不必要的复杂性的臭味.简单地把数据库实例保存在一个全局变量中会更容易一些.

#### 19.3 时间卡、销售凭条以及服务费用
图19.7中展示了向雇员中登记时间卡操作的静态结构.图19.8中展示了该操作的动态模型.基本思路是,该操作从
PayrollDatabase中得到Employee对象,向Employee对象请求它的PaymentClassification对象,然后创建一个
TimeCard对象并把该对象增加到PaymentClassification中.

注意,不能把TimeCard对象增加到一般的PayClassification对象中,只能增加到HourlyClassification中.意味
着必须把Employee获取的PaymentClassification对象向下转型为HourlyClassification.如TimeCard-
TransactionImpl.

PayrollTest.timeCardTransaction是测试用例,测试验证向钟点工加入时间卡.代码是创建钟点工加入数据库.
接着,创建TimeCardTransaction并调用execute().然后,检查HourlyClassification包含适当的TimeCard

TimeCard只是数据类,用了长整数表示日期.因为没有便于使用的Date类.也许很快就要一个,但是现在不需要.
我向专注于手边的工作.通过当前测试用例.最后,会编写一个需要真正Date类的测试用例.到那时,会回来更新
TimeCard类.

程序TimeCardTransaction和TimeCardTransactionImpl.注意,其中使用简单的自负床异常.这不是好的长期实
践,但是足以满足初期需求.在实际需要的异常有了解后,再回来创建有意义的异常类.

图19.9和图19.10展示了向应支付薪水的雇员中登记销售凭条操作的设计.

图19.11和图19.12展示向协会成员登记服务费用操作的设计.

这些设计指出操作模型和已创建的核心模型间的适配.核心Employee对象可以和许多不同组织间有从属关系,但是
操作模型却假定所有从属关系都是协会从属关系.因此,操作模型就无法识别从属关系的明确种类.相反,它只是假定
如果向雇员中登记了服务费用,那么该雇员就具有协会从属关系.

动态模型解决了这个两难问题.它再Employee对象中包含了一组Affiliation对象中搜寻UnionAffiliation对象.
然后,把ServiceCharge增加到搜寻到的UnionAffiliation对象中.

PayrollTest.addServiceCharge().简单地创建钟点雇员对象并向其中增加一个UnionAffiliation.同时,也确
保向PayrollDatabase中注册了适当的协会成员id.接着,创建一个ServiceChargeTransaction并执行之.最后,
证明ServiceCharge确实被加入到Employee的UnionAffiliation中.

#### 19.3.1 代码与UML
在画19.12时,用从属关系对象取代NoAffiliation是更好的设计.这样更灵活点.然而,在编写程序PayrollTest.
addServiceCharge()时,我认识到调用Employee的setAffiliation要比调用addAffiliation更好一些.毕竟,
需求并没有要求雇员有多个Affiliation.所以没有必要使用强转中选择.如果这些做会带来不必要的复杂性.

这个例子说明画太多的UML图而没有验证代码是危险的.这里,我在UML中就放入一些不需要的结构.也许,这些
结构总有一天会派上用途.但是必须维护他们,抵不上维护的代价.

如果不使用Affiliation对象列表,实现起来会简单很多.会继续保持Null Object模式以及NoAffiliation类.

ServiceChargeTransaction.没有了搜寻UnionAffiliation对象的循环,该类确实简单不少,简单地从数据库
中获取Employee对象,把该对象的Affiliation向下转型为UnionAffiliation,接着把ServiceCharge加入其中.

#### 19.4 更改雇员属性
图19.13和19.14展示了更改雇员属性操作的静态结构.从用例6很容易得到这个结构.因为所有的操作都以empId
作为参数,所以创建更高的基类ChangeEmployeeTransaction.该基类的下面一层是修改单个属性的类,比如:
ChangeNameTransaction和ChangeAddressTransaction.改变雇员类别的操作有共同的行为,都会修改Employee
对象的同一个字段.因此,可以把它们放在抽象基类ChangeClassificationTransaction之下.更改支付方式和
从属关系的操作与此雷同.从ChangeMethodTransaction类和ChangeAffiliationTransaction类的结构中可以看
到这一点.

图19.15展示了所有更改操作的动态模型.其中再次使用Template Method模式.对于所有的更改操作,都必须要
从PayrollDatabase中去除对应于EmpId的Employee对象.因此,ChangeEmployeeTransaction的execute()实现
了这个行为,然后给自己发送Change消息.Change方法被声明为虚的并在派生类中实现.如图19.16和图19.17所示.

PayrollTest.changeNameTransaction()展示了ChangeNameTransaction的测试用例.它使用AddHourlyEmployee
操作创建了名为Bill的钟点工.接着,创建并执行ChangeNameTransaction操作,该操作把雇员名字更改为Bob.
最后,从PayrollDatabase中去除该雇员实例并验证名字已经被更改.

程序ChangeEmployeeTransaction.从中明显看到Template Method模式的结构.execute()方法只是从Payroll-
Database中读取适当的Employee实例,如果成功,就调用纯虚函数change().

#### 19.4.1 更改雇员类别
图19.18展示ChangeClassificationTransaction的动态行为.再次使用Template Method模式.该操作创建了新的
PaymentClassification对象,然后把它传给Employee对象.这一点是通过向自己发送getClassification消息完
成的.在ChangeClassificationTransaction的每个派生类中,都要实现getClassification这个抽象方法.如图
19.19-图19.21所示.

程序PayrollTest.changeHourlyTransaction().测试用例中使用AddCommissionedEmployee操作创建了一个应
支付酬金的雇员.接着,创建一个ChangeHourlyTransaction对象并执行它.然后,去除已经被更改的雇员对象并验
证它的PaymentClassification成员指向的是具有正确每小时报酬的HourlyClassification类型的对象,以及
它的PaymentSchedule成员指向的是WeeklySchedule类型的对象.

程序ChangeClassificationTransaction.再一次明显使用Template Method模式.Change()方法调用了两个纯虚
函数getClassification()和getSchedule().它使用这两个函数的返回值来设置Employee的类别以及支付薪水
时间表.

ChangeHourlyTransaction类的实现.实现了从ChangeClassificationTransaction继承的getClassification()
和getSchedule()方法,从而完善了Template Method模式.它的getClassification()方法返回新创建的Hourly-
Classification对象.它的getSchedule()方法返回一个新创建的WeeklySchedule.

//todo ChangeSalariedTransaction和ChangeCommissionedTransaction的实现也留给读者作为练习.
ChangeMethodTransaction的实现使用了类似的机制.用抽象方法getMethod来选择适当的PaymentMethod派生
对象,然后把该派生对象传个Employee对象.(参见图19.22-图19.25)

这样类的实现简单且不惊奇.同样把它们留作联系.

图19.26展示了ChangeAffiliationTransaction的实现.其中再次使用了Template Method模式来选择应该给
Employee对象的Affiliation派生对象.(参见图19.27-图19.29)

#### 19.4.2 我当时抽什么烟了
在实现这个设计时,有件事令人惊讶.

像往常一样,通过编写ChangeMemberTransaction的测试用例来实现该类.创建并执行ChangeMemberTransaction
把Bill放入协会中.接着核实Bill绑定UnionAffiliation对象并且该UnionAffiliation对象具有正确的会费.

令我惊讶的事就隐藏在该测试用例的最后几行.这些行用来证实PayrollDatabase记录了Bill的协会成员关系.
现有的UML图中没有显示出这一点.UML图仅仅关注Employee对象应该和适当的Affiliation派生对象绑定在一起.
我没有注意到这个缺陷,你呢?

按照UML图,我愉快的编写这些操作,然后等待单元测试失败.一旦失败发生,就可以很明显地发现所忽视的东西.
但是问题的解决方案不那么明显,如何让ChangeMemberTransaction记录成员关系,而让ChangeUnaffiliated-
Transaction清除该成员关系呢?

答案时给ChangeAffiliationTransaction增加另一个纯虚函数RecordMembership.在ChangeMemberTransaction
中该函数把memberId和Employee实例绑定起来.在ChangeUnaffiliatedTransaction中该函数清除掉成员关系
记录.

程序ChangeAffiliationTransaction.很明显,再次使用了Template Method模式

我对这个设计不是很满意.ChangeUnaffiliatedTransaction必须要知道UnionAffiliation是一件讨厌的事情.
如果在Affiliation类中放入抽象方法recordMembership和eraseMembership就可以解决这个问题.不过,这样
做会迫使UnionAffiliation和NoAffiliation要知道PayrollDatabase.而这同样不能令我满意.

尽管如此,但是目前的实现非常简单并且只是轻微地违反了OCP.还好,系统中只有极少模块知道ChangeUnaffiliated-
Transaction.所以它额外的依赖关系不会造成太大的危害.

#### 19.5 支付雇员薪水
最后,我们来考虑一下这个应用的核心操作:指示系统给合适的雇员支付薪水.图19.29展示了PaydayTransaction
类的静态结构.图19.30=图19.33描绘了相关的动态行为.

图19.32和图19.33中描绘的算法引入了登记(posting)的概念.再计算出正确的支付数额并发送到Employee后,会
登记支付信息;也就是说,要更新涉及支付信息的记录.这样,我们就可以把calculatePay方法定义为计算从最近
的登记日期至指定日期间的薪水.

#### 19.5.1 我们希望开发人员做商务决策吗
登记这个概念从哪里来的呢?在用户素材或者用例肯定没有提到它.我只是碰巧虚构了这么一个概念来解决我所
察觉到的问题.担心会使用同一日期,或者同一支付期内的日期多次调用Payday方法,所以我想确保不会出现多次
支付雇员薪水的情况.我是主动这样做的,没有询问客户,这似乎就是应该要做的事情.

实际上,我做了一个商务决策.断定多次运行薪水支付程序会产生不同的结果.我本应该去询问客户或者项目管理
人员,因为他们也许会有完全不同的想法.

在和客户协商后,发现违反了客户的意图.客户希望运行薪水支付程序后检查一下支付支票.如果有错,客户希望
可以更正支付信息并再次运行程序.客户告诉我根本不应该考虑当前支付期之外的时间卡或者销售凭条.

所以,我不得不抛弃有关登记的方案.当时它似乎像是一个好想法,但却不是客户想要的.
