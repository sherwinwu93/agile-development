###
很早以前,我们就编写了支持和验证前面所讲述的设计的代码.本章中,我会以微小增量的方法来创建该代码,但是
只在文中适当的地方才展示它.文中,你只会看到完整形式的代码快照,请不要被其误导认为代码就是以那种形式
编写的.事实上,在你所看见的每块代码之间,都有许多的编辑、编译和测试用例,它们都对代码进行了微小的改进.

同样,你也会看到相当多的UML图.请把这些UML图看作是我快速在白板上勾画的草图,用来向你展示我的想法.UML
为你我之间的交流提供了方便的媒介.

图19.1显示出我们用一个名为Transaction的抽象基类来代表操作,该类具有一个名为execute()的实例方法.这
当然是Command模式.Transaction类的实现如Transaction.j  
Transaction.j

#### 19.1 增加雇员
图19.2展示了一个增加雇员操作的可能结构.请注意,正式这些操作把雇员的支付薪水时间表和他们的支付薪水类
别关联起来.这样做是合适的,因为这些操作是人工发明物而不是核心模型的一部分.所以,核心模型不会察觉到关
联;关联只是我们附加上去的内容,并且可以随时更改.例如:可以容易地增加一种更改雇员支付薪水时间表的操作.

19.2.AddEmployeeTranaction的静态模型.v

同样请注意,缺省的支付方式是由出纳人员保存支付支票.如果雇员希望采用另一种支付方式,就必须要使用适当
的chgEmp操作进行更改.

如往常一样,我们使用测试优先的方法来编写代码.PayrollTest是一个测试用例,用来证明addSalariedTransaction
可以正确地工作.随后的代码将会通过该测试用例.

#### 19.1.1 薪水支付系统数据库
AddEmployeeTransaction类使用了一个名为PayrollDatabase的类.PayrollDatabase类在一个以empId为键值的
Map中保存着全部现有的Employee对象.同时,它也持有一个把协会的memberId映射为empId的Map.图19.3中展示
了该类的结构.PayrollDatabase是一个Facade模式的例子.

程序PayrollDatabase展示了PayrollDatabaseImpl类的初步实现.该实现是为了帮助通过最初的测试用例.它还没有
包含把协会会员id映射为Employee实例的Map对象.

一般而言,我认为数据库是实现细节.应该尽可能地推迟有关这些细节的决策.不管这个特定的数据库是RDBMS、平
面文件(flat file)或者OODBMS实现的.此时都是无关紧要的.现在,我仅仅对创建为应用程序的其他部分提供数据
库服务的API感兴趣.随后,我会发现有关数据库的合适实现.

推迟有关数据库的细节是一项不常见、但却很值得的实践.我们常常会一直等到对软件及其需要有了更多的知识时,
才进行有关数据库的决策.通过等待,我们避免了把过多的基础结构放入数据库中的问题.我们更愿意仅仅实现刚好
满足应用程序需要的数据库功能.

#### 19.1.2 使用Template Method模式来增加雇员
图19.4展示了增加雇员的动态模型,为了得到正确的PaymentClassification对象和PaymentSchedule对象,请注
意AddEmployeeTransaction对象向自己发送了一个消息.AddEmployeeTransaction类的派生类实现了这些消息.
这是一个Temple Method模式的应用.

程序AddEmployeeTransaction和程序AddEmployeeTransactionImpl中展示了AddEmployeeTransaction类中
Template Method 模式的实现.该类的execute()方法中调用了两个会派生类中实现的纯虚函数.getSchedule()
和getClassification()这两个函数返回新创建的Employee对象所需要的PaymentSchedule和Payment-
Classification对象.接着,execute()方法把这些对象绑定到Employee对象上并把Employee对象存入Payroll-
Database中.

AddEmployeeTransaction.j  
AddEmployeeTransactionImpl.j  

程序AddSalariedEmployee和程序AddSalariedEmployeeImpl展示了AddSalariedEmployee的实现.该类派生自
AddEmployeeTransaction类并在getSchedule()方法和getClassification()方法的实现中传回合适的对象给
AddEmployeeTransaction.execute().

AddSalariedEmployee.j  
AddSalariedEmployeeImpl.j

#### 19.2 删除雇员
图19.5和图19.6中展现了删除雇员操作的静态和动态模型.

程序中展示了删除雇员的测试用例.程序和程序展示了deleteEmployeeTransaction的实现.这是一个非常典型的
Command模式的实现.构造函数保存了execute()方法最后会使用的数据.


