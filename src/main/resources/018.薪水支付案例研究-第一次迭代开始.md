#### 介绍
这案例研究描述了简单的批量处理薪水支付系统开发的第一次迭代过程.案例研究中的用户素材是很简单.例如,其
中完全没有提及税金方面的内容,这是初期迭代的特征.其中仅仅提供客户所需非常小的商务价值中.  
我们进行快速的分析和设计会话,通常发生在正规迭代开始时.客户以及挑选了素材,我们必须知道怎样去实现.这样
的设计会话简短且粗略.此处的UML图只是草图,在下一章进行实际的设计工作,完成单元测试和实现.

#### 18.1.1 规格说明
下面是和客户关于第一次迭代中的素材记录:
1. 有些雇员是钟点工.按雇员记录的每小时报酬字段进行支付.它们每天提交工作时间卡,其中记录了日期以及工作
小时数.如果每天工作超过8小时,超出的部分按之前的1.5倍进行支付.
2. 有些雇员以月薪进行支付.每个月最后一个工作日对他们进行支付.有一个月薪字段.
3. 同时,对于带薪雇员,根据销售情况,支付给一定数量的酬金.他们会提交销售凭条,记录了销售日期和数量.他们的
雇员记录中酬金报酬字段.每隔一周的周五进行支付.
4. 雇员可选择支付方式.可以把支付支票邮寄到他们指定的邮政地址;也可以把支票保持在出纳人员随时支取;或者
要求将薪水直接存入他们指定的银行账户.
5. 有些雇员加入协会.在他们的雇员记录中有每周应付款项字段.这些应付款必须要从薪水中扣除.协会有时也会
针对单个协会会员征收服务费用.协会每周会提交这些服务费用,服务费用必须从下个月薪水总额中扣除.  
6. 薪水支付程序每工作日运行一次,并且当天为相应的雇员进行支付.系统会被告知雇员的支付日期,这样会计算

从雇员上次支付日期到规定的本次支付日期应支付的数额.  

我们可以首先生成数据库模式,可以使用关系数据库,并且从需求中清楚地知道表和字段的可能样子.可以容易地设
计出可用的数据库模式,然后再构建一些查询.使用这种方法,数据库成为了关注的中心.  
数据库是实现细节!尽可能地推迟考虑数据库,太多程序之所以和数据库耦合,就是因为一开始就把数据库考虑.请
记住抽象的定义:本质部分的方法,无关紧要部分的去除.在项目当前阶段数据库就是无关紧要的:它只不过是一项
用来存储和访问数据的技术而已.  

#### 18.2 基于用例分析

我们先来考虑系统的行为而不是系统的数据.毕竟,别人付给我们报酬正是要创建系统的行为.  

一种捕获、分析系统行为的方法是创建用例.按照最初Jacobson的描述,用例和XP中用户素材的概念非常相似.用例
就像是用稍多一点细节详细描述用户素材.一旦在当前迭代中要实现该用户素材,这种详尽细节就是合适的.  
用例分析是,我们关注用户素材和验收测试,以找出系统用户会执行的操作种类.接下来我们会努力弄清楚系统怎样
去相应这些操作.  

例如,下面的用户素材:
1. 增加新雇员
2. 删除雇员
3. 登记时间卡
4. 登记销售凭条
5. 登记协会服务费
6. 更改雇员明细(例如,每小时报酬,会费)
7. 在当日运行薪水支付系统  

让我们把这些用户素材转换成具有详细细节的用例.不需要陷入过多细节--只要有助于考虑出实现每个素材的代码
设计即可.

#### 18.2.1 增加雇员
##### 用例1 增加新雇员
使用AddEmp操作(transaction)增加新的雇员.该操作包含雇员的名字、地址以及分配的雇员号.该操作有3种形式
1. AddEmp < EmpId "name" "address" H hourly-rate
2. AddEmp < EmpId "name" "address" S monthly-salary
3. AddEmp < EmpId "name" "address" C monthly-salary commission-rate  
雇员记录时根据对应字段的值来创建的.  

###### 异常情况:描述操作的结构有错误.
如果描述操作的结构不正确,会把错误消息打印出来,并且不进行处理.  

用例1中隐含着一个抽象.虽然AddEmp操作有3种形式,但是共享EmpID、name以及address字段.我们可以使用
Command模式创建具有3个派生类的抽象基类AddEmployeeTransaction,这3个派生类是:AddHourlyEmployeeTransaction、
AddSalariedEmployeeTransaction和AddCommissionedEmployeeTransaction. 如下图  
AddEmployeeTransaction类结构层次结构.v  

通过把每项工作划分进自己类中,这个结构很好地遵循了SRP.另一种方法,把所有工作放入一个模块.虽然这样
可以减少系统中类的数目,并且使系统更简单.但是同样使所有的操作处理集中,造成了庞大且容易出错的模块.  
用例1明确地提到了雇员记录,其中暗含这几分数据库的意味.对于数据库的倾向会再次引诱我们去考虑数据库
结构,但是我们应该抵制这些欲望.用例真正要求我们是去创建个雇员.雇员的对象模型是什么呢?比这更好一
点的提问是,这3个不同的操作创建了什么呢?在我看来,它们创建了3个不同种类的雇员对象,其结构和3个不同
种类的AddEmp操作相仿.下图展示了可能的结构.  
可能的Employee类层次结构.vsdx  

#### 18.2.2 删除雇员
##### 用例2 删除雇员
使用delEmp操作来删除雇员.该操作使用如下形式:
1. delEmp I empId  
当执行该操作时,会删除对应的雇员记录.  
###### 异常情况1: 无效或者未知的empId
打印错误,不进行处理.  
此时,该用例没有提供任何设计方面的洞察力.
#### 18.2.3 登记时间卡
##### 用例3 登记时间卡
执行TimeCard操作时,会创建一条时间卡记录,并把该记录和对应的雇员记录关联起来.
1. TimeCard I empId date hours
###### 异常1: 选择的不是钟点雇员
打印错误,不做处理
###### 异常2: 描述操作的结构有错误
打印错误,不做处理  
该用例指出,一些操作只应用于某类雇员,这加强了不同种类的雇员用不同的类表示的观点.在此用例中,暗含了
时间卡和钟点雇员之间的关联.下图展示了该关联的一个可能的静态模型.
HourlyEmployee和TimeCard间的关联.v
#### 18.2.4 登记销售凭条
##### 用例4 登记销售凭条
执行SalesReceipt操作时,系统会创建新的销售凭条记录,并关联该记录和对应的应支付酬金的雇员关联起来.  
SalesReceipt I empId date amount  
###### 异常1:选择的雇员不是支付酬金的
打印错误,不做处理
###### 异常2: 描述操作的结构有错误
打印错误,不做处理  
暗含的结构如下图  
应支付酬金的雇员和销售凭条间的关系.v  
#### 18.2.5 登记协会服务费
##### 用例5 登记协会服务费
操作时,系统创建一条服务费用记录,并且关联该记录和对应的协会成员.
1. ServiceCharge I memberId amount
###### 异常1: 描述操作结构错误
操作不是良好组织,或者empId不是协会成员.那么打印错误.  
该用例说明不能通过雇员id去访问协会陈冠.协会维护者它自己针对协会成员的标识编号系统.因此,系统必须
关联协会成员和雇员.有多种不同的方法完成关联.为了避免随意性,我们把决策推迟到后面进行.也许,来自系统
其他部分约束会促使我们做出某种选择.
#### 18.2.6 更改雇员明细
##### 用例6 更改雇员明细
操作时,系统会更改对应雇员记录的详细信息之一.可能有以下变体:
1. chgEmp I empId name 更改雇员名
2. chgEmp I empId address 更改雇员地址
3. chgEmp I empId hourlyRate 更改每小时报酬
4. chgEmp I empId (S) salary 更改薪水
5. chgEmp I empId (C) salary rate 更改酬金
6. chgEmp I empId hold 持有支票
7. chgEmp I empId (Direct)bank account 直接存款
8. chgEmp I empId (Mail) address 邮寄支票
9. chgEmp I empId (Member) memberId (Dues) rate 使雇员加入协会
10. chgEmp I empId (NoMember) 从协会去掉雇员  
###### 异常: 操作错误
如果操作结构错误或者empId没有引用到雇员,或者memberId已经引用了一个协会成员,那么打印错误,不做处理.  


该例非常有启迪性.表明了雇员信息中可以改变的内容.可以把钟点雇员改为带薪雇员的事实是不起当的(可能的
Employee类层次结构).相反,在薪水计算中使用strategy模式或许更加恰当.Employee类可以持有Payment-
Classification(类别)的策略类,如下图所示.这是有好处的因为可以无需改动Employee对象的任何部分即可更换
PaymentClassification对象.把钟点雇员更改为带薪雇员时,像一个Employee对象的HourlyClassification对
象被SalariedClassification对象取代.

有3种不同的PaymentClassification对象.Hourlyclassification对象中保存者每小时报酬以及一个TimeCard
对象列表.SalariedClassification对象中保存者月薪数字.CommissionedClassification对象中保存着月
新、酬金报酬以及一个SalesReceipt对象列表.其中使用了组合(composition)关系,因为我认为当雇员对象
被摧毁时,TimeCard以及SalesReceipt对象也应该被摧毁.  

同样,支付的方式也应该可以改变.下图使用Strategy模式实现了这个想法,并从PaymentMethod类派生出3种
不同的子类.如果Employee对象种包含MailMethod对象,那么相应雇员会使他的支付支票邮寄给自己.MailObject
对象种记录了支票要邮寄到的地址.如果Employee对象种包含DirectMethod对象,那么他的薪水会直接存入
DirectMethod对象种记录的银行账户种.如果Employee对象中包含HoldMethod对象,那么他的支付支票会发送
到出纳人员那里保存以随时支取.  

最后,对于协会成员关系应用了Null Object模式.每个Employee对象包含两种Affiliation对象.如果包含No-
Affiliation对象,那么他的薪水除老板外不会被组织调整.然而,如果Employee对象包含UnionAffiliation对
象,那么雇员就必须支付UnionAffiliation对象中记录的会费和服务费.  

修订后的薪水支付系统类图--核心模型.v

这些模式的使用使得该系统很好地符合了开闭OCP.Employee类对于支付方式,支付类别以及协会从属关系的变化
使封闭的.这样就可以不影响Employee类的情况下向系统中增加新的支付方式、支付类别以及协会从属关系.  
上图成为了核心模型或者架构.它使薪水支付系统做的所有工作的核心.在薪水支付应用程序中还有许多其他的
类和设计,但是相对于这个基础结构而言,它们都是次要的.当然,这个结构也不是一成不变:它会和其他所有部分
一起演化.
#### 18.2.7 发薪日
##### 用例7 现在运行薪水支付应用程序
执行Payday操作时,系统会找到所有应该在指定日期进行支付的雇员.接着系统确定出他们的应扣款额,并根据
所选择的支付方式对他们进行支付.
1. Payday date  

虽然用例意图很容易理解,但确定上图中的静态结构造成的影响不那么简单.我们需要回答几个问题.  
首先,Employee对象怎样知道如何计算它的薪水?如果是钟点工,系统应当清点他的时间卡并乘以每小时报酬.
如果是销售,系统应当清点他的销售凭条,乘以酬金报酬系数,并加上基础薪水.但是在哪里完成这种计算呢?
PaymentClassification的派生对象似乎是个理想的地方.这些对象保存着计算薪水需要的数据,所以它们或许
应该拥有确定薪水的方法.下图展示一个协作图,描述了可能的工作方式.  
018.计算雇员薪水.v  

在要求Employee对象计算薪水时,该对象把这个请求转交给PaymentClassification对象.所采用的实际计算
方法依赖于Employee对象包含的PaymentClassification对象的类型.下面三张图展示3种可能.  
018.计算钟点雇员的薪水.v  
018.计算应支付酬金雇员的薪水.v  
018.计算带薪雇员的薪水.v

#### 18.3 反思: 我们学到了什么
我们已经知道,简单的用例分析可以提供丰富的信息以及系统设计的洞察力. 上面三张图就是通过思考这些用例
得到的,更确切地说,是通过思考行为得到的.

#### 18.4 找到潜在的抽象
为了有效地使用OCP,必须要搜寻并找出隐藏于应用背后的抽象.通常,应用的需求,甚至用例不会表述,甚至间接
提及这些抽象.需求和用例太关注于细节以至于不能表达潜在抽象的一般性.

该应用中的潜在抽象是什么呢?再来看一下需求,看到这样的陈述,"一些雇员按小时工作","一些雇员完全以月薪
进行支付",以及"一些[...]雇员会支付给他们一定数量的酬金".这暗示了下面的一般性:"所有的雇员都被支付,
但是支付策略是不同的".这里的抽象是"所有雇员都被支付".计算三图的PaymentClassification模型很好地表
达这个抽象.因此,通过非常简单的用例分析,就发现了用户素材中的抽象.

#### 18.4.1 支付薪水时间表抽象
在寻找其他的抽象过程中,我们发现了这样的陈述,"每周五支付","每月的最后一个工作日支付"以及"每隔一周的
周五支付".这引导我们得到另一个一般性:"所有的雇员都是按照某种支付薪水时间表进行支付的".这里的抽象体
现为支付薪水时间表的概念.应该可以询问Employee对象某个日期是否是它的支付日期.用例中几乎没有提及此
事.需求把雇员支付薪水时间表和支付类别关联起来.更明确地说,每周支付钟点雇员,每月支付带薪雇员,以及每
两周支付雇员酬金;然而,这个关联是问题的本质吗?难道不会在某天改变策略,以便于雇员选取特别的支付薪水
时间表,或者便于率属于不同科室或者不同部门的雇员可以有不同的支付薪水时间表吗?难道支付薪水时间策略
不会独立于支付策略变化吗?当然,这是可能发生的.

如果按照需求的暗示,把支付薪水时间表问题委托给PaymentClassification类,那么该类对于支付薪水时间方
面的变化就不是封闭的.当改变支付策略时,必须要测试和支付薪水时间相关的代码.当改变支付薪水时间表时,
同样必须也要测试支付策略.OCP和SRP都被违反了.

支付薪水时间表和支付策略之间的关联会导致一些bug,比如对于特定支付策略的更改会导致某些雇员具有不正确
的支付薪水时间表.像这样的bug对于程序员是正常的,但是管理人员以及用户会对此感到恐惧.他们害怕如果对于
支付策略的更改会破坏支付薪水时间表,那么任何地方的任何更改就会导致系统的任何其他无关部分出现问题,而
事实上也正式如此.他们害怕无法预测更改带来的影响.如果不能预测更改带来的影响,就会丧失信心,并且程序也
会给管理人员和用户留下"危险且不稳定"的印象.

尽管存在支付薪水时间表抽象的本质特性,但是用例分析却没有给我们提供有关它的存在的任何直接线索.要发现
它就需要仔细地考虑需求,并且要能够洞察出用户社团的误导.过度信赖工具和过程以及低估智力和经验都是灾难
的源泉.

下面两图展示支付薪水时间表抽象的静态和动态模型.正如你看到的,我们再次使用Strategy模式.Employee类
包含了抽象PaymentSchedule类.PaymentSchedule类有3中形式,分别对应于3种已知的雇员支付薪水时间表.  
018.支付薪水时间表抽象的静态模型.v  
018.支付薪水时间表抽象的动态模型.v  

#### 18.4.2 支付方式
从需求中可以获取的另一个一般性是"所有的孤雁都通过某种方式收到他们的薪水".这个抽象就是PaymentMethod
类.非常有趣,该抽象已经在 图核心模型 中表达出来了.

#### 18.4.3 从属关系
需求中暗示着雇员可以和协会有从属关系;然而协会并非唯一有权从雇员薪水中收取一些费用的组织.雇员可能想
自动地为某些慈善团体捐款或者自动地交付一些专业协会的费用.因此,一般性就变成"雇员可以属于许多组织,并
应该自动地从该雇员的薪水中支付这些组织的费用."

相应的抽象是 图核心模型 展示的Affiliation类.不过,图中并没有显示出Employee包含多个Affiliation,并且
图中显示出来NoAffiliation类.这个设计不是非常吻合我们现在认为需要的抽象. 下面两图 展示了表示
Affiliation抽象的静态和动态模型.

由于使用Affiliation对象列表,所以就无需对那些没有从属关系的雇员使用Null Object模式.现在,如果雇员没
有从属关系,只要把他或者她的从属关系对象列表设置为空即可.

#### 18.5 结论
在一次迭代开始,开发团队通常会聚集在一个白板前,一起思考这次迭代中要实现的用户素材的设计.这种快速设计
会话持续的时间一般会小于一个小时.如果产生了一些UML图,那么这些图会留在白板上,或者被擦掉.会话的目的
是发起思考活动,并为开发人员提供一个公共的,可以依据其展开工作的智力模型,而不是为了确定设计.  

本章就是这样一个快速设计会话的原原本本的再现.
