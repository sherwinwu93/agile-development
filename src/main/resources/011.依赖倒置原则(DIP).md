### 依赖倒置原则
#### 11.1 依赖倒置原则(DIP)
1. 高层模块不应该依赖于低层模块,二者都应该依赖与抽象
2. 抽象不应该依赖于细节.细节应该依赖于抽象.  
传统的软件开发方法,总是抽象依赖于细节.一个设计良好的面向对象程序,就是把传统倒置过来,细节
依赖于抽象.(相当于作文列大纲).  

如果高层依赖于低层,对低层模块的改动就会直接影响高层模块,从而迫使它们依次做出改动.  
我们更希望能够重用高层的策略设置模块.我们已经非常擅长于修改子程序的形式来重用低层模块.
如果高层模块依赖于低层模块,那么在不同的上下文中重用高层模块会变得非常困难.然而,如果高层
模块独立于低层模块,那么高层模块的就可以非常容易地被重用.  
该原则是框架设计的核心原则.
#### 11.2 层次化
所有结构良好的面向对象构架都具有清晰的层次定义,每个层次通过一个定义良好的、受控的接口向外
提供一组内聚的服务.  
高层的PolicyLayer使用低层的MechanismLayer,而MechanismLayer又使用更细节的层UtilityLayer.隐藏
了一个错误.PolicyLayer对于其下一直到UtilityLayer的改动都是敏感的.这种依赖关系是传递的.
#### 11.2.1 倒置的接口所有权
Don't call us, we'll call you.低层模块实现了在高层模块中声明并被高层模块调用的接口.  
通过倒置接口的所有权,对于MechanismLayer或者UtilityLayer不会影响到PolicyLayer.通过倒置
这些依赖关系,我们创建了一个更灵活、更持久、更易改变的结构.
#### 11.2.2 依赖于抽象
程序中所有的依赖关系都应该终止于抽象类或者接口
1. 任何变量都不应该持有一个只想具体类的指针或者引用
2. 任何类都不应该从具体类派生
3. 任何方法都不应该覆写它的任何基类中的已经实现了的方法.
#### 11.3 一个简单的例子
#### 找出潜在的对象
什么是高层策略?它是应用背后的抽象,是那些不随着具体细节的改变而改变的真理.它是系统内部的系统-
它是隐喻.在Button/Lamp例子中,背后的抽象是检测用户的开/关指令并将指令传达给目标对象.用
什么机制检测用户的指令呢?无关紧要!目标对象是什么?统一无关紧要!这些都是不会影响到抽象的具体
细节.
#### 11.4 熔炉示例
#### 静态多态性和动态多态性
模板方法的缺点是:
1. Heater和Thermometer的类型不能再运行时更改
2. 对于新类型的header和thermometer的使用会迫使重新编译和重新部署
#### 11.5 结论
传统创建出来的依赖关系结构,策略时依赖于细节的.这是糟糕的,因为这样会是策略收到细节改变的影响.
面向对象的程序设计倒置了依赖关系结构,使得细节和策略都依赖于抽象,并且常常是客户拥有服务接口.  
事实上,这种依赖关系的倒置正是好的面向对象设计的标志所在.使用何种语言来编写程序是无关紧要的.
如果程序的依赖关系是倒置,它就是面向对象的设计.如果程序的依赖关系不是倒置的,它就是过程化的设计.  
依赖倒置原则是实现了面向对象技术所宣称的好处的基本低层机制.抽象和细节被彼此隔离,所以代码也非常
容易维护.