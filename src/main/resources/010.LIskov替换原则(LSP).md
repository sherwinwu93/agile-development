### Liskov替换原则(LSP)
OCP背后的主要机制是抽象(abstraction)和多态(polymorphism).在静态类型语言中,支持抽象和多态的关键机制之一是继承.正是使用了继承,
我们才可以创建实现其基类(base class) 中的抽象方法的派生类.
#### 10.1 Liskov替换原则(LSP)
子类型(subtype)必须能够替换掉它们的基类型(base type). 
违反了LSP, D 继承与 B. B有方法f(B). 测试时测试f(D),违反了的话,f(D)可能报错,其他B的子类都有问题.违反了f(B)不变OCP.
#### 10.2 一个违反LSP的简单例子
对于LSP的违反常常会导致以明显违反OCP的方式使用运行时类型辨别(RTTI).这种方式常常时使用一个显式的if语句或者if/else链去确定一个
对象的类型,以便于可以选择针对该类型的正确行为.
#### 010.1 对LSP的违反导致了对OCP的违反
Square类和Circle类不能替换Shape类其实是违反了LSP,这个违反又迫使DrawShape函数违反了OCP,因而,对于LSP的违反也潜在地违反了OCP.
#### 10.3 正方形和矩形,更微妙的违规
#### 010.2 Rectangle类
#### 10.3.1 真正的问题
#### 10.3.2 有效性并非本质属性
LSP让我们得出一个非常重要的结论:一个模型,如果孤立地看,并不具有真正意义上的有效性.模型的有效性只能通过它的客户程序来表现.例如,
如果孤立地看,最后哪个版本的Rectangle和Square是自相容且有效的.但是如果从对基类做出了一些合理假设的程序员的角度来看,这个模型就
是有问题的.
#### 10.3.3 IS-A是关于行为的
对于那些不是g的编写者而言,正方形可以是长方形,但是从g的角度来看,Square对象绝对不是Rectangle对象.  
为什么!因为Square对象的行为方式和函数g所期望的Rectangle对象的行为方式不相容.  
从行为方式的角度来看,Square不是Rectangle,对象的行为方式才是软件真正所关注的问题.  
LSP清楚地指出,OOD中IS-A关系是就行为方式而言的,行为方式是可以进行合理假设的,是客户程序所依赖的.
#### 10.3.4 基于锲约设计
DBC(Design By Contract).  
锲约是通过为每个方法声明的前置条件和后置条件来指定的.要是一个方法得以执行,前置条件为真.执行完毕后,该方法要保证后置条件为真.  
##### 派生类的前置条件和后置条件规则是
在派生类中的例程时,前置更弱或相等,后置更强或相等
#### 10.3.5 在单元测试中指定锲约
单元测试彻底测试一个类的行为使类的行为更加清晰
#### 10.4 一个实际的例子
#### 10.4.1 动机
不用关心适配后的Set的具体类型,在内存紧张而速度要求不严格时,使用UnboundedSet,在内存充裕而对速度有严格要求时,程序员可以选择
BoundedSet.客户通过Set的接口来操纵这些对象的,因此不必关心使用的时那种Set.
#### 10.4.2 问题