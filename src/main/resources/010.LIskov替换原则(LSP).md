### Liskov替换原则(LSP)
OCP背后的主要机制是抽象(abstraction)和多态(polymorphism).在静态类型语言中,支持抽象和多态的关键机制之一是继承.正是使用了继承,
我们才可以创建实现其基类(base class) 中的抽象方法的派生类.
#### 10.1 Liskov替换原则(LSP)
子类型(subtype)必须能够替换掉它们的基类型(base type). 
违反了LSP, D 继承与 B. B有方法f(B). 测试时测试f(D),违反了的话,f(D)可能报错,其他B的子类都有问题.违反了f(B)不变OCP.
#### 10.2 一个违反LSP的简单例子
对于LSP的违反常常会导致以明显违反OCP的方式使用运行时类型辨别(RTTI).这种方式常常时使用一个显式的if语句或者if/else链去确定一个
对象的类型,以便于可以选择针对该类型的正确行为.
#### 010.1 对LSP的违反导致了对OCP的违反
Square类和Circle类不能替换Shape类其实是违反了LSP,这个违反又迫使DrawShape函数违反了OCP,因而,对于LSP的违反也潜在地违反了OCP.
#### 10.3 正方形和矩形,更微妙的违规
#### 010.2 Rectangle类
#### 10.3.1 真正的问题
#### 10.3.2 有效性并非本质属性
LSP让我们得出一个非常重要的结论:一个模型,如果孤立地看,并不具有真正意义上的有效性.模型的有效性只能通过它的客户程序来表现.例如,
如果孤立地看,最后哪个版本的Rectangle和Square是自相容且有效的.但是如果从对基类做出了一些合理假设的程序员的角度来看,这个模型就
是有问题的.
#### 10.3.3 IS-A是关于行为的
对于那些不是g的编写者而言,正方形可以是长方形,但是从g的角度来看,Square对象绝对不是Rectangle对象.  
为什么!因为Square对象的行为方式和函数g所期望的Rectangle对象的行为方式不相容.  
从行为方式的角度来看,Square不是Rectangle,对象的行为方式才是软件真正所关注的问题.  
LSP清楚地指出,OOD中IS-A关系是就行为方式而言的,行为方式是可以进行合理假设的,是客户程序所依赖的.
#### 10.3.4 基于锲约设计
DBC(Design By Contract).  
锲约是通过为每个方法声明的前置条件和后置条件来指定的.要是一个方法得以执行,前置条件为真.执行完毕后,该方法要保证后置条件为真.  
##### 派生类的前置条件和后置条件规则是
在派生类中的例程时,前置更弱或相等,后置更强或相等
#### 10.3.5 在单元测试中指定锲约
单元测试彻底测试一个类的行为使类的行为更加清晰
#### 10.4 一个实际的例子
#### 10.4.1 动机
不用关心适配后的Set的具体类型,在内存紧张而速度要求不严格时,使用UnboundedSet,在内存充裕而对速度有严格要求时,程序员可以选择
BoundedSet.客户通过Set的接口来操纵这些对象的,因此不必关心使用的时那种Set.
#### 10.4.2 问题
加入第三方持久性集合中的元素必须得从PersistentObject派生.由于PersistentSet只是把调用委托给第三方持久性集合,所以任何要加入
PersistentSet得元素必须得从PersistentObject派生.可是Set接口没有这样的限制.  
当客户程序向Set加入元素时,不能确保Set实际上是否时一个PersistentSet.因而,客户程序没有办法知道它所加入的元素是否应该从
PersistentObject派生.
#### 10.4.3 不符合LSP的解决方案
约定方式: 不让PersistentSet和PersistentObject暴露整个应用程序.在特定的模块,负责从持久性设备读出所有容器,也负责把所有容器写入
到持久性存储设备.在写入容器时,容器的内容先被复制到对应PersistentObject的派生对象中.
#### 10.4.4 符合LSP的解决方案
我承认PersistentSet和Set之间不存在IS-A关系,它不应派生自Set.因此我会分离这个层次结构,但不是完全的分离.Set和PersistentSet之间
有一些公有的特性.事实上,仅仅时Add方法致使在LSP原则下出了问题.因此,我创建了一个层次结构,其中Set和PersistentSet是兄弟关系,统一
在一个具有测试成员关系、遍历等操作的抽象接口下.这就可以对PersistentSet对象进行遍历以及测试成员关系等操作.但是它不能够把不是派
生自PersistentObject的对象加入到PersistentSet中.
#### 10.5 用提取公共部分的方法代替继承
大多数情况下,接受一个多态行为中的微妙错误比试着修改设计完全符合LSP更为不利.  
接受缺陷而不是追求完美是一个工程上的权衡问题.不过.不应该轻易放弃对LSP的遵循.保证子类代替父类是有效的管理复杂性的方法.一旦放弃
这一点,就必须单独考虑每个子类.  
##### 关于提取公共部分
如果一组类都支持一个公共的职责,那么它们应该从一个公共的超累继承该职责.如果公共的超类还不存在,那么就创建一个,并把公共的职责放入
其中.毕竟,这样一个类的有用性是确定无疑的.此时这个新创建的超累可能回事一个抽象类.
#### 10.6 启发式规则和习惯用法
派生类完成功能少于父类,通常不能替换父类,违反了LSP
#### 10.6.1 派生类中的退化函数
#### 10.6.2 从派生类中抛出异常
#### 10.7 结论
OCP是OOD中很多说法的核心.有效应用LSP,应用程序会具有更多的可维护性、可重用性以及健壮性.  
子类型的可替换性才使得基类类型的模块在无需修改的情况下就可以拓展.这种可替换性必须是开发人员可以隐式依赖的东西.  
因此,如果没有显示地强制基类类型的契约,那么代码就必须良好地并且明显地表达出这一点.  
"IS-A"的含义过于宽泛而无用.子类型的正确定义是"可替换性的".可以通过显式或隐式的锲约来定义.
