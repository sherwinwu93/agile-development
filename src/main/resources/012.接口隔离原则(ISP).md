### 接口隔离原则(ISP)
这个原则用来处理"胖(fat)"接口所具有的缺点.如果类的接口不是内聚的(cohesive),就表示该类具有"胖"的接口.  
胖接口可以分解为多组方法,每组方法服务于不同的客户程序.
#### 12.1 接口污染
##### 012.1 安全系统中的Door
解决方案:Door继承了TimerClient,TimedDoor也就继承了TimeClient.这就保证了TimerClient可以把自己注册到Timer中,收到TimeOut消息.  
问题:Door依赖于TimerClient了,但不是所有的Door都需要定时供暖.如果创建了无需定时功能的Door的派生类,就必须提供TimeOut方法的退化
实现--这就有可能违法LSP.此外,即使不使用TimerClient类的定义,也必须要引入它,这样就具有了不必要的复杂性以及不必要的重复的臭味.
#### 12.2 分离客户就是分离接口
Door接口和TimerClient接口被完全不同的客户程序使用的.Timer使用TimerClient,而操作门的类使用Door.既然客户程序是分离的,所以接口
也应该保持分离.为什么呢?因为客户程序对它们使用的接口施加反作用力
##### 客户对接口施加的反作用力
我们考虑软件中引起变化的作用力时,通常考虑的都是接口的变化会怎样影响它们的使用者.例如,如果TimerClient的接口改变了,我们会去关心
TimerClient的所有使用者要做什么样的改变.有时,迫使接口改变的,正是它们的使用者.  
例如,有些Timer的使用者注册多个超时通知请求.对于TimedDoor来说,当它检测到门被打开时,会向Timer发送一个Register消息,请求一个超时
通知.可是,在超时到达前,门关上了,关闭一会儿后又被再次打开.这就导致在原先的超时到达前又注册了一个新的超时请求.最后,最初的超时到
达,TimedDoor的timeOut方法被调用.Door错误地发出了警报.  
使用惯用手法(convention),可以改正上面情形的错误.在每次超时注册中都包含一个唯一的timeoutId码,并在调用TimerClient的timeout方法,
再次使用该标识码.这样TimerClient的每个派生类就都可以根据这个标识码知道应该响应哪个超时请求.
#### 12.3 接口隔离原则(ISP)
不应该强迫客户依赖于它们不用的方法.
#### 12.4 类接口与对象接口
再次考虑一个TimedDoor问题--Timer以及Door.因为实现这两个接口需要操作同样的数据,所以这两个接口必须在同一个对象中实现.  
那么怎样才能遵循isp呢?怎样才能分离必须在一起实现的接口呢?  
一个对象的客户不是必须通过该对象的接口去访问它,也可以通过委托或者通过该对象的基类去访问它.
#### 12.4.1 使用委托分离接口 TimedDoor.j
#### 12.4.2 使用多重继承分离接口 BetterTimedDoor.j
#### 12.5 ATM用户界面的例子
ATM界面层次结构.u 


