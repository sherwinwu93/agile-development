### 接口隔离原则(ISP)
这个原则用来处理"胖(fat)"接口所具有的缺点.如果类的接口不是内聚的(cohesive),就表示该类具有"胖"的接口.  
胖接口可以分解为多组方法,每组方法服务于不同的客户程序.
#### 12.1 接口污染
##### 012.1 安全系统中的Door
解决方案:Door继承了TimerClient,TimedDoor也就继承了TimeClient.这就保证了TimerClient可以把自己注册到Timer中,收到TimeOut消息.  
问题:Door依赖于TimerClient了,但不是所有的Door都需要定时供暖.如果创建了无需定时功能的Door的派生类,就必须提供TimeOut方法的退化
实现--这就有可能违法LSP.此外,即使不使用TimerClient类的定义,也必须要引入它,这样就具有了不必要的复杂性以及不必要的重复的臭味.
#### 12.2 分离客户就是分离接口
Door接口和TimerClient接口被完全不同的客户程序使用的.Timer使用TimerClient,而操作门的类使用Door.既然客户程序是分离的,所以接口
也应该保持分离.为什么呢?因为客户程序对它们使用的接口施加反作用力
##### 客户对接口施加的反作用力
我们考虑软件中引起变化的作用力时,通常考虑的都是接口的变化会怎样影响它们的使用者.例如,如果TimerClient的接口改变了,我们会去关心
TimerClient的所有使用者要做什么样的改变.有时,迫使接口改变的,正是它们的使用者.  
例如,有些Timer的使用者注册多个超时通知请求.对于TimedDoor来说,当它检测到门被打开时,会向Timer发送一个Register消息,请求一个超时
通知.可是,在超时到达前,门关上了,关闭一会儿后又被再次打开.这就导致在原先的超时到达前又注册了一个新的超时请求.最后,最初的超时到
达,TimedDoor的timeOut方法被调用.Door错误地发出了警报.  
使用惯用手法(convention),可以改正上面情形的错误.在每次超时注册中都包含一个唯一的timeoutId码,并在调用TimerClient的timeout方法,
再次使用该标识码.这样TimerClient的每个派生类就都可以根据这个标识码知道应该响应哪个超时请求.
#### 12.3 接口隔离原则(ISP)
不应该强迫客户依赖于它们不用的方法.
#### 12.4 类接口与对象接口
再次考虑一个TimedDoor问题--Timer以及Door.因为实现这两个接口需要操作同样的数据,所以这两个接口必须在同一个对象中实现.  
那么怎样才能遵循isp呢?怎样才能分离必须在一起实现的接口呢?  
一个对象的客户不是必须通过该对象的接口去访问它,也可以通过委托或者通过该对象的基类去访问它.
#### 12.4.1 使用委托分离接口 TimedDoor.j
#### 12.4.2 使用多重继承分离接口 BetterTimedDoor.j
#### 12.5 ATM用户界面的例子
ATM界面层次结构.u  
ATM操作层次结构.u  
这是应该避免的改动,对于每个Transaction的派生类的改动都会迫使UI的相对改动,从而影响到了
其他所有Transaction的派生类.这样的设计就具有僵化性以及脆弱性的臭味.  
将UI接口分解成DepositUI、WithdrawUI以及TransferUI,可以避免不合适的耦合.最终的UI接口
可以去多重继承这些单独的接口.  
每次创建Transaction新的派生类,抽象接口UI就需要增加一个相应的基类,并且因此UI接口以及所有
它的派生类必须改变.不过,这些类并没有被广泛的使用.事实上,它们可能仅被main使用.  
因此,增加新的UI基类所带来的影响被减至最小.  
分离的ATM UI接口.u  
UI.j
#### 多参数形式与单参数形式
UI.j
多参数形式优先于单参数形式使用.
1. 对客户进行分组:根据客户调用的服务方法对客户进行分组,这种方法使得可以为每组而不是每个
客户创建分离的接口.极大地减少了服务需要实现的接口,同时避免让服务依赖于每个客户类型.
2. 改变接口:维护程序时,常常会改变现有的类和组件的接口.通常这些改变会造成巨大的影响.
这种影响可以通过为现有的对象增加新接口的方法来缓解.原有接口的客户如果想访问新接口中方法,
可以通过对象去询问该接口.
#### 12.6 结论
胖类会导致客户程序之间产生有害的耦合关系.当一个客户程序要求该胖类进行改动时,会影响到
所有其他客户程序.

