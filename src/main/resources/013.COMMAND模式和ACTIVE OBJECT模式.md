### COMMAND模式和ACTIVE OBJECT模式
Command.j  
从严格的面向对象意义来,这种做法时被强烈反对的--因为它具有功能分解的味道.它把函数层面的任务提升到了
类的层面.然而,在这两个思维范式的碰撞处,有趣的事情发生了.  
#### 13.1 简单的Command
复印机软件中一些简单的Command.u
#### 13.2 事务操作
另一个COMMAND模式的常见用法是创建和执行事务操作,该用法在薪水支付(Payroll)问题中很有用.
#### 13.2.1 实体上解耦和时间上解耦
好处在于很好地解除了从用户获取数据的代码、验证并操作数据的代码以及业务对象本身之间的耦合问题.例如,
可能会有人想通过某些GUI中的对话框来获取增加新雇员时需要的数据.如果GUI代码中包含了该操作中的验证
和执行算法,这样的耦合会使得验证和执行代码无法在其他的接口中使用.通过把验证和执行代码分离到
AddEmployeeTransaction类中,我们从实体上解除了该代码和获取数据的接口间的耦合关系.更甚者,也分离
知道如何操作数据库逻辑的代码和业务实体本身
#### 13.2.2 时间上解耦
解耦了验证和执行代码.一旦获取了数据,可以把事务操作对象放在一个列表中,以后再进行验证和执行.  
假如我们有个数据库必须在一天之内保持不变.对数据库的修改只能在夜里0点和1点之间进行.一直等到午夜,
然后匆匆忙忙在1点钱把所有的命令都输入进去.如果能够当场验证,然后在午夜再执行.
#### 13.3 undo
给command模式增加了undo()方法.如果command派生类的doE()方法可以记住它所执行的操作的细节,那么
undo方法就可以取消这些操作,并把系统恢复到原先的状态.  
用户画圆的时候.把这个新圆对象的ID作为自己的私有变量存储起来.接着,doE()方法返回.然后,系统把这个执行
过的DrawCommand对象压入已完成的命令堆栈中.  随后用户点击了undo,系统弹出已完成命令堆栈栈顶的Command
对象,并调用该对象的undo()方法.接受到undo()消息时,DrawCircleCommand对象从当前画布上显示的对象的列表
中删除和自己所保存的ID匹配的圆. 
#### 13.4 ACTIVE OBJECT模式
这是实现多线程控制的项目古老的技术.
activeobject.ActiveObjectEngine.j  
这似乎没有给人太深刻的印象.但是想象一下如果链表中的一个Command对象会克隆自己并把克隆对象放到链表
的尾部.这个链表永远不会为空,run()函数永远不会返回.  
SleepCommand.j
