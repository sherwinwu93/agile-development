### 第20章 包的设计原则
随着程序规模和复杂度增加,需要更高层次对它们进行组织.类对于小型程序来说是非常方便的组织单元,对于
大型程序,如果仅仅使用类,会显得粒度过细.因此,就需要比类大的东西来辅助大型程序的组织.

6个原则.前3个关注内聚性,指导我们对类组包.后3个关注耦合性,帮助我们确定包的相互关系.最后两个原则描
述 依赖性管理度量,据此对设计的依赖结构进行度量和刻画.
#### 20.1 如何进行包的设计
在UML的概念中,包可以用作包容一组类的容器.通过把类组织成包,我们可以在更高层次的抽象上来理解设计.我
们也可以通过包来管理软件的开发和发布.目的就是根据一些原则对程序中的类进行划分,然后把那些划分后的
类分配到包中.

但是类经常会和其他类之间存在依赖关系.这些依赖关系还经常会跨越包的边界.因此,包之间也会产生依赖关系
.包之间的依赖关系展现了程序的高层组织结构,我们应该对这些关系进行管理.

这提出了很多问题:  
1. 在向包中分配类时应该依据什么原则?
2. 应该使用什么设计原则来管理包之间的关系?
3. 包的设计应该先于类呢(自顶向下)?还是类的设计应该先于包(自底向上)?
4. 如何实际表现出"包"?在C++中如何表现?在Java中如何表现?在某种开发环境中又如何表现?
5. 包创建好后,我们应当将它们用于何种目的?

本章讲诉6个设计原则,涉及包的创建、相互关系的管理以及包的使用.前3个原则是用来指导如何把类划分到
包中.后3个原则是用来处理包之间的相互关系的.

#### 20.2 粒度:包的内聚性原则
这里要讲诉的3个关于包的内聚性原则,可以帮助开发者决定如何把类划分到包中.这些原则依赖于这样的事实:
至少已经存在一些类,并且它们之间的相互关系也已经确定.因此,这些原则是根据"自底向上"的观点对类进行
划分的.
#### 20.2.1 重用发布等价原则(REP)
重用的粒度就是发布的粒度.


当你重用一个库类时,对这个类库的作者有什么期望呢?你当然想得到好的文档,可以工作的代码,规格清晰的
接口等待.但是.你还会有其他的期望.

首先,你希望代码的作者能保证为你维护这些代码,只有这样才值得你在重用这些代码上花费时间.毕竟.如果
需要你亲自去维护这些代码,那将会花费你大量的时间,这些时间也许可以自己用来设计一个小些但是好些的
包.

其次,你希望代码的作者在计划对代码的接口和功能进行任何改变时,提前通知你一下.但是仅仅通知一下是
不够的.代码的作者必须尊重你拒绝使用任何新版本的权力.否则.当你处在开发进度中的一个关键时刻时,
他可能发布了一个新的版本,或者他对代码进行了改变,之后就干脆在也无法与你的系统兼容了.

无论在哪种情况下.如果你决定不接纳新版本,作者必须保证对于你所使用的旧版本继续提供一段时间的支持.
这段时间也许只有3个月.或者长达1年.你们两个人之间必须就这些事情进行协商.但是,他不能够和你断绝
关系并且拒绝对你提供支持.如果他不同意对你使用的稍旧一点的版本提供支持,那么你就应该认真的考虑
一下是否情愿忍受对方反复无常的变化,而继续使用他的代码.

这个问题主要是行政问题.如果有其他的人将要重用代码,就必须要进行行政和支持方面的工作.但是这些行
政的问题对于包结构具有深刻的影响.为了给重用者提供所需的保证,代码的作者必须把它们的软件组织到
一个可重用的包中,并且通过版本号对那些包进行跟踪.

REP指出,一个包的重用粒度可以和发布粒度一样大.我们所重用的任何东西都必须同时被发布和跟踪.简单
的编写一个类.然后声称它是可重用的做法是不现实的.只有在建立一个跟踪系统.为潜在的使用者提供所需
要的变更通知,安全性以及支持后,重用才有可能.

REP带给我们了关于如何把设计划分到包中的第一个提示.由于重用性必须是基于包,所以可重用的包必须包
含可重用的类.因此,至少,某些包应该由一组可重用的类组成.

行政上的约束力将会影响到对于软件的划分,这看上去令人不安,但是软件不是一个可以依赖纯数字规则组织
起来的纯数学实体.软件是一个人的智力活动的产品.软件由人创建并被人使用,并且如果我们将要对软件进
行重用.那么它肯定以一种人认为方便重用的方式进行划分.

那么,关于包的内部结构方法,我们学到了什么呢?我们必须从潜在的重用者的角度去考虑包的内容.如果一个
包中的软件是用来重用的.那么它就不能再包含不是为了重用目的而设计的软件.一个包中的软件要么是可
重用的,要么都不是可重用的.

可重用性不是唯一的标准,我们也要考虑重用这些软件的人.当然,一个容器类库是可重用的,一个金融方面的
框架也是可重用的.但是,我们不希望把它们放到同一个包中.很多希望重用容器类库的人可能对于金融框架
根本不感兴趣.因此,我们希望一个包中的所有类对于同一类用户来说都是可重用的.我们不希望一个用户包
中所包含的类中,一些是他所需要的.另一些对他却完全不适合.

#### 20.2.2 共同重用原则(CRP)
一个包中的所有类应该是共同重用的.如果重用了包中的一个类,那么就要重用包中的所有类.


这些原则可以帮助我们决定哪些类应该放在同一个包中.它规定了趋向于共同重用的类应该属于同一个包.

类很少会孤立的重用.一般来说,可重用的类需要与作为该可重用抽象一部分的其他类协作.CRP规定了这些
类应该属于同一个包.在这样的一个包中,我们会看到类之间有很多的互相依赖.

一个简单的例子是容器类以及与它管理的迭代器类.这些类彼此之间紧密耦合在一起,因此必须共同重用.所
以它们应该在同一个包中.

但是,CRP告诉我们的不仅仅是什么类应该共同放入一个包中.它还告诉我们什么类不应该放入同一个包中.
当一个包使用了另一个包时,它们之间会存在一个依赖关系.也许一个包仅仅使用了另外一个包中的一个类.
然而,那根本不会削弱这两个包之间的依赖关系.使用者依然依赖于被使用的包.每当被使用的包发布时,使
用者包必须要进行重新验证和重新发布.即使发布的原因仅仅是由于更改了一个使用者包根本不关心的类,
也必须要这样做.

此外,包也经常以共享库,jar等物理表现得形式出现.如果被使用的包以JAR的形式发布,那么使用这个包的
代码就依赖于整个JAR.对JAR的任何修改--即使所修改的是与用户代码无关的类,仍然会造成这个JAR的一个
新版本的发布.这个JAR仍然要重新发布,并且使用这个JAR的代码也要进行重新验证.

因此.我想确信当我依赖于一个包时,我将依赖于那个包中的每一个类.换句话说,我想确信我放入一个包中的
所有类是不可分开的,仅仅依赖于其中一部分的情况是不可能的,否则,我将要进行不必要的重新验证和重新
发行,并且会白费相当数量的努力.

因此,CRP告诉我们更多的是,什么类不应该放在一起.CRP规定相互之间没有紧密联系的类不应该在同一个包
中.

#### 20.2.3 共同封闭原则(CCP)
包中的所有类对于同一类性质的变化应该是共同封闭的.一个变化若对一个包产生影响,则将对该包中的所有
类产生影响,而对于其他的包不造成任何影响.

这是单一职责原则对于包的重新规定.正如SRP规定的一个类不应该包含多个引起变化的原因那样,这条原则
规定了一个包不应该包含多个引起变化的原因.

在大多数的应用中,可维护性的重要性是超过可重用性的.如果一个应用中的代码必须更改,那么我们宁愿都
集中在一个包中,而不是分布在多个包中.如果更改集中在一个单一的包中,那么我们仅仅需要发布那一个
更改了的包.不依赖那个更改了的包的其他包则不需要重新验证或者重新发布.

CCP鼓励我们把可能由于同样的原因而更改的所有类共同聚集在同一个地方.如果两个类之间有非常紧密的
绑定关系.不管是物理上的还是概念上的,那么它们总是会一同进行变化,因而它们应该属于同一个包中.这样
会减少软件的发布、重新验证、重新发布的工作量.

这个原则和开放封闭原则OCP密切相关.本原则中"封闭"这个词和OCP中的具有同样的含意.OCP规定了类对
于修改应该是封闭.对于扩展应该是开放的.但是正如我们所学到的,100%的封闭是不可能做到的.应当进行
有策略的封闭.我们所设计的系统应该对于我们经历过的最常见的变化做到封闭.

CCP通过把对于一些确定的变化类型开饭的类共同组织到同一个包中,从而增强了上述内容.因而,当需求中
的一个变化到来时,那个变化就会很有可能被限制在最小数量的包中.

#### 20.2.4 包内聚性总结
过去,我们对内聚性的认识要远比上面3个原则所蕴含的简单.我们习惯于认为内聚性不过是指一个模块执行
一项并且仅仅一项功能.然而,这3个关于包内聚性的原则描述了有关内聚性的更加丰富的变化.在选择要共
同组织到包中的类时,必须要考虑可重用性于可开发性之间的相反作用力.在这些作用力和应用的需要之间
进行平衡不是一件简单的工作.此外,这个平衡几乎总是动态的.也就是说,今天看起来合适的划分到了明年
也许就不再合适了.因此,当项目的重心从可开发新向可重用性转变时,包的组成很可能会变动并随时间而演
化.

#### 20.3 稳定性:包的耦合性原则
接下来的3个原则用来处理包之间的关系.这里,我们会再次碰到可开放性和逻辑设计之间的冲突力.来自技
术和行政方面的作用力都会影响到包的组织结构.并且这种作用力还是易变的.

#### 20.3.1 无环依赖原则
在包的依赖关系图中不允许存在环
你曾经有过这样的经历吗?工作了一整天,终于完成了某项功能后回家,不料第二天早晨一来却发现那项功能
不再工作了.原因是什么呢?因为有人比你走的更晚,并且更改了你所依赖的某些东西!我称其为"晨后综合症"

如果开发环境中存在有许多开发人员都在更改相同的源代码文件集合的情况,那么就会发生晨后综合症.在
仅有几个开发人员的相对小的项目中,这不是一个大问题.但是当项目和开发团队的规模增长时,晨后综合症
就会带来可怕的噩梦.在缺乏纪律的团队中,几周都无法构建出一个稳定的项目版本的情况是很常见的.相反,
每个人都忙于一遍遍地更改他们的代码,试图使之能够相容于其他人所做的最近更改.

近几十年来,逐步形成了两个针对该问题的解决方案.这两个方案都来自电信业.第一个是"每周构建",第二
个是ADP.
=======
### 第20章 包的设计原则
随着程序规模和复杂度增加,需要更高层次对它们进行组织.类对于小型程序来说是非常方便的组织单元,对于
大型程序,如果仅仅使用类,会显得粒度过细.因此,就需要比类大的东西来辅助大型程序的组织.

6个原则.前3个关注内聚性,指导我们对类组包.后3个关注耦合性,帮助我们确定包的相互关系.最后两个原则描
述 依赖性管理度量,据此对设计的依赖结构进行度量和刻画.
#### 20.1 如何进行包的设计
在UML的概念中,包可以用作包容一组类的容器.通过把类组织成包,我们可以在更高层次的抽象上来理解设计.我
们也可以通过包来管理软件的开发和发布.目的就是根据一些原则对程序中的类进行划分,然后把那些划分后的
类分配到包中.

但是类经常会和其他类之间存在依赖关系.这些依赖关系还经常会跨越包的边界.因此,包之间也会产生依赖关系
.包之间的依赖关系展现了程序的高层组织结构,我们应该对这些关系进行管理.

这提出了很多问题:  
1. 在向包中分配类时应该依据什么原则?
2. 应该使用什么设计原则来管理包之间的关系?
3. 包的设计应该先于类呢(自顶向下)?还是类的设计应该先于包(自底向上)?
4. 如何实际表现出"包"?在C++中如何表现?在Java中如何表现?在某种开发环境中又如何表现?
5. 包创建好后,我们应当将它们用于何种目的?

本章讲诉6个设计原则,涉及包的创建、相互关系的管理以及包的使用.前3个原则是用来指导如何把类划分到
包中.后3个原则是用来处理包之间的相互关系的.

#### 20.2 粒度:包的内聚性原则
这里要讲诉的3个关于包的内聚性原则,可以帮助开发者决定如何把类划分到包中.这些原则依赖于这样的事实:
至少已经存在一些类,并且它们之间的相互关系也已经确定.因此,这些原则是根据"自底向上"的观点对类进行
划分的.
#### 20.2.1 重用发布等价原则(REP)
重用的粒度就是发布的粒度.


当你重用一个库类时,对这个类库的作者有什么期望呢?你当然想得到好的文档,可以工作的代码,规格清晰的
接口等待.但是.你还会有其他的期望.

首先,你希望代码的作者能保证为你维护这些代码,只有这样才值得你在重用这些代码上花费时间.毕竟.如果
需要你亲自去维护这些代码,那将会花费你大量的时间,这些时间也许可以自己用来设计一个小些但是好些的
包.

其次,你希望代码的作者在计划对代码的接口和功能进行任何改变时,提前通知你一下.但是仅仅通知一下是
不够的.代码的作者必须尊重你拒绝使用任何新版本的权力.否则.当你处在开发进度中的一个关键时刻时,
他可能发布了一个新的版本,或者他对代码进行了改变,之后就干脆在也无法与你的系统兼容了.

无论在哪种情况下.如果你决定不接纳新版本,作者必须保证对于你所使用的旧版本继续提供一段时间的支持.
这段时间也许只有3个月.或者长达1年.你们两个人之间必须就这些事情进行协商.但是,他不能够和你断绝
关系并且拒绝对你提供支持.如果他不同意对你使用的稍旧一点的版本提供支持,那么你就应该认真的考虑
一下是否情愿忍受对方反复无常的变化,而继续使用他的代码.

这个问题主要是行政问题.如果有其他的人将要重用代码,就必须要进行行政和支持方面的工作.但是这些行
政的问题对于包结构具有深刻的影响.为了给重用者提供所需的保证,代码的作者必须把它们的软件组织到
一个可重用的包中,并且通过版本号对那些包进行跟踪.

REP指出,一个包的重用粒度可以和发布粒度一样大.我们所重用的任何东西都必须同时被发布和跟踪.简单
的编写一个类.然后声称它是可重用的做法是不现实的.只有在建立一个跟踪系统.为潜在的使用者提供所需
要的变更通知,安全性以及支持后,重用才有可能.

REP带给我们了关于如何把设计划分到包中的第一个提示.由于重用性必须是基于包,所以可重用的包必须包
含可重用的类.因此,至少,某些包应该由一组可重用的类组成.

行政上的约束力将会影响到对于软件的划分,这看上去令人不安,但是软件不是一个可以依赖纯数字规则组织
起来的纯数学实体.软件是一个人的智力活动的产品.软件由人创建并被人使用,并且如果我们将要对软件进
行重用.那么它肯定以一种人认为方便重用的方式进行划分.

那么,关于包的内部结构方法,我们学到了什么呢?我们必须从潜在的重用者的角度去考虑包的内容.如果一个
包中的软件是用来重用的.那么它就不能再包含不是为了重用目的而设计的软件.一个包中的软件要么是可
重用的,要么都不是可重用的.

可重用性不是唯一的标准,我们也要考虑重用这些软件的人.当然,一个容器类库是可重用的,一个金融方面的
框架也是可重用的.但是,我们不希望把它们放到同一个包中.很多希望重用容器类库的人可能对于金融框架
根本不感兴趣.因此,我们希望一个包中的所有类对于同一类用户来说都是可重用的.我们不希望一个用户包
中所包含的类中,一些是他所需要的.另一些对他却完全不适合.

#### 20.2.2 共同重用原则(CRP)
一个包中的所有类应该是共同重用的.如果重用了包中的一个类,那么就要重用包中的所有类.


这些原则可以帮助我们决定哪些类应该放在同一个包中.它规定了趋向于共同重用的类应该属于同一个包.

类很少会孤立的重用.一般来说,可重用的类需要与作为该可重用抽象一部分的其他类协作.CRP规定了这些
类应该属于同一个包.在这样的一个包中,我们会看到类之间有很多的互相依赖.

一个简单的例子是容器类以及与它管理的迭代器类.这些类彼此之间紧密耦合在一起,因此必须共同重用.所
以它们应该在同一个包中.

但是,CRP告诉我们的不仅仅是什么类应该共同放入一个包中.它还告诉我们什么类不应该放入同一个包中.
当一个包使用了另一个包时,它们之间会存在一个依赖关系.也许一个包仅仅使用了另外一个包中的一个类.
然而,那根本不会削弱这两个包之间的依赖关系.使用者依然依赖于被使用的包.每当被使用的包发布时,使
用者包必须要进行重新验证和重新发布.即使发布的原因仅仅是由于更改了一个使用者包根本不关心的类,
也必须要这样做.

此外,包也经常以共享库,jar等物理表现得形式出现.如果被使用的包以JAR的形式发布,那么使用这个包的
代码就依赖于整个JAR.对JAR的任何修改--即使所修改的是与用户代码无关的类,仍然会造成这个JAR的一个
新版本的发布.这个JAR仍然要重新发布,并且使用这个JAR的代码也要进行重新验证.

因此.我想确信当我依赖于一个包时,我将依赖于那个包中的每一个类.换句话说,我想确信我放入一个包中的
所有类是不可分开的,仅仅依赖于其中一部分的情况是不可能的,否则,我将要进行不必要的重新验证和重新
发行,并且会白费相当数量的努力.

因此,CRP告诉我们更多的是,什么类不应该放在一起.CRP规定相互之间没有紧密联系的类不应该在同一个包
中.

#### 20.2.3 共同封闭原则(CCP)
包中的所有类对于同一类性质的变化应该是共同封闭的.一个变化若对一个包产生影响,则将对该包中的所有
类产生影响,而对于其他的包不造成任何影响.

这是单一职责原则对于包的重新规定.正如SRP规定的一个类不应该包含多个引起变化的原因那样,这条原则
规定了一个包不应该包含多个引起变化的原因.

在大多数的应用中,可维护性的重要性是超过可重用性的.如果一个应用中的代码必须更改,那么我们宁愿都
集中在一个包中,而不是分布在多个包中.如果更改集中在一个单一的包中,那么我们仅仅需要发布那一个
更改了的包.不依赖那个更改了的包的其他包则不需要重新验证或者重新发布.

CCP鼓励我们把可能由于同样的原因而更改的所有类共同聚集在同一个地方.如果两个类之间有非常紧密的
绑定关系.不管是物理上的还是概念上的,那么它们总是会一同进行变化,因而它们应该属于同一个包中.这样
会减少软件的发布、重新验证、重新发布的工作量.

这个原则和开放封闭原则OCP密切相关.本原则中"封闭"这个词和OCP中的具有同样的含意.OCP规定了类对
于修改应该是封闭.对于扩展应该是开放的.但是正如我们所学到的,100%的封闭是不可能做到的.应当进行
有策略的封闭.我们所设计的系统应该对于我们经历过的最常见的变化做到封闭.

CCP通过把对于一些确定的变化类型开饭的类共同组织到同一个包中,从而增强了上述内容.因而,当需求中
的一个变化到来时,那个变化就会很有可能被限制在最小数量的包中.

#### 20.2.4 包内聚性总结
过去,我们对内聚性的认识要远比上面3个原则所蕴含的简单.我们习惯于认为内聚性不过是指一个模块执行
一项并且仅仅一项功能.然而,这3个关于包内聚性的原则描述了有关内聚性的更加丰富的变化.在选择要共
同组织到包中的类时,必须要考虑可重用性于可开发性之间的相反作用力.在这些作用力和应用的需要之间
进行平衡不是一件简单的工作.此外,这个平衡几乎总是动态的.也就是说,今天看起来合适的划分到了明年
也许就不再合适了.因此,当项目的重心从可开发新向可重用性转变时,包的组成很可能会变动并随时间而演
化.

#### 20.3 稳定性:包的耦合性原则
接下来的3个原则用来处理包之间的关系.这里,我们会再次碰到可开放性和逻辑设计之间的冲突力.来自技
术和行政方面的作用力都会影响到包的组织结构.并且这种作用力还是易变的.

#### 20.3.1 无环依赖原则(ADP)
在包的依赖关系图中不允许存在环
你曾经有过这样的经历吗?工作了一整天,终于完成了某项功能后回家,不料第二天早晨一来却发现那项功能
不再工作了.原因是什么呢?因为有人比你走的更晚,并且更改了你所依赖的某些东西!我称其为"晨后综合症"

如果开发环境中存在有许多开发人员都在更改相同的源代码文件集合的情况,那么就会发生晨后综合症.在
仅有几个开发人员的相对小的项目中,这不是一个大问题.但是当项目和开发团队的规模增长时,晨后综合症
就会带来可怕的噩梦.在缺乏纪律的团队中,几周都无法构建出一个稳定的项目版本的情况是很常见的.相反,
每个人都忙于一遍遍地更改他们的代码,试图使之能够相容于其他人所做的最近更改.

近几十年来,逐步形成了两个针对该问题的解决方案.这两个方案都来自电信业.第一个是"每周构建",第二
个是ADP.

#### 20.3.2 每周构建
每周构建常常应用在中等规模的项目中.它的工作方式为:在一周的前4天.所有的开发人员互不打扰.工作在
各自私有的代码拷贝上,而不担心互相之间的集成问题.周五,他们集成进各自的更改并构建系统.

这样,开发人员每周可以单独工作4天,这具有极大的好处.当然,不利之处在于周五要付出巨大的集成代价.

糟糕的是,随着项目的增长,集成工作变得无法在周五完成.集成的工作量会一直增加到需要周六加班才能完
成.只需几次这样的周六加班,开发人员就会认为其实应该在周四开始集成.这样,集成的起始时间就会慢慢
蔓延至一周的中期.

随着开发和集成时间比率的降低,团队的效率也随之降低.最后,这会非常的令人沮丧,以至于开发人员或者
或者项目管理者宣称应该把构建安排为每两周一次.这种做法暂时可以应付一下,但是集成的时间仍然不断
地随着项目规模一起增长.

这最终会导致危机.为了保持效率,就必须要不断地延长构建周期.但是,延长构建周期会增加项目的风险.
集成和测试会变得越来越难进行.团队也丧失了快速反馈带来的好处.

#### 20.3.3 消除依赖环
通过把开发环境划分成可发布的包,可以解决上述问题.这些包可以作为工作单元被一个开发人员或者一个
开发团队拆出(check out).当开发人员使一个包可以工作时,就把它发布给其他开发人员使用.他们赋予该
包一个版本号并把它移到一个供其他开发人员使用的目录中.接着,他们可以在自己的私有区域中继续修改
他们的包.其他所有人都使用那个已经发布的版本.

当制作了一个包的新版本时,其他开发团队可以决定是否马上采用这个新的版本.如果决定不采用,则他们完
全可以继续使用老的版本.一旦觉得自己准备就绪,就可以开始使用新的版本.

因此,所有的开发团队都不会受其他开发团队支配.对一个包作的更改不必立即反应到其他开发团队中.每个
开发团队独立决定何时采用目前所使用的包的新版本.此外,集成是以小规模增量的方式进行的.这样,就不
会再发生所有的开发人员必须集合到一起把他们做的每一件工作集成起来的情况.

这是一个非常简单、合理的过程,并被广泛使用.不过,要使其能够工作,就必须要对包的依赖关系结构进行管
理.包的依赖关系结构中不能有环.如果依赖关系结构中存在环,那么就不能避免晨后综合症.

考虑图20.1中的包图.图中展示了组成一个应用程序的非常典型的包结构.相对于本例的意图来说,该应用程序
的功能并不重要.重要的是包的依赖关系结构.请注意,该结构是一个有向图.其中,包是结点,依赖关系是有向
边.

现在,请注意另外一件事情.无论从哪个包开始,都无法沿着依赖关系而绕回到这个包.该结构中没有环.它是一
个有向无环图(DAG).

当负责MyDialogs的团队发布了该包的一个新版本时,会很容易找出受到影响的包:只需逆着依赖关系指向寻找
即可.因此,MyTasks和MyApplication都会受到影响.当前工作于这两个包的开发人员就要决定何时应该和My-
Dialogs的新版本集成.

还要注意,当MyDialogs发布时.完全不会影响到系统中许多其他的包.它们不知道MyDialogs.并且也不关心何
时对MyDialogs进行了更改.这很好.这意味着发布MyDialogs的影响相对较小.

当工作于MyDialogs包的开发人员想要进行该包的测试时,只需把他们的MyDialogs版本和当前正使用的Windows
包的版本一起编译,链接即可.不会涉及到系统中任何其他的包.这很好.这意味着工作于MyDialogs的开发人员
只需较少的工作即可建立一个测试,而且他们要考虑的变数也不多.

当发布整个系统时,是自底向上进行的.首先编译、测试以及发布Windows包.接着是MessageWindow和MyDialogs.
在它们之后是Task,然后是TaskWindow和Database.接着是MyTasks,最后是MyApplication.这个过程非常清
楚并且易于处理.我们知道如何去构建系统,因为我们理解系统各个部分之间的依赖关系.

#### 20.3.4 包依赖关系图中环造成的影响
如果一个新需求迫使我们更改MyDialogs中的一个类去使用MyApplication中的一个类.这就产生了一个依赖
关系环,如图20.2所示.

这个依赖关系环会导致一些直接后果.例如,工作于MyTasks包的开发人员知道,为了发布MyTasks包,他们必须
得兼容Task、MyDialogs、Database以及Windows.然而,由于依赖关系环得存在,他们现在必须也要兼容My-
Application、TaskWindow以及MessageWindow.也就是说,现在MyTasks依赖于系统中所有其他得包.这就致
使MyTasks非常难以发布.MyDialogs有着同样得问题.实际上,该依赖关系环会迫使MyApplication、TaskWindow
以及MessageWindow.也就是说,现在MyTasks依赖于系统中所有其他得包.这就致使MyTasks非常难以发布.My-
Dialogs有着同样的问题.事实上,该依赖关系环会迫使MyApplication、MyTasks以及MyDialogs总是同时发布.
它们实际上已经变成了同一个打包.于是,在这些包上工作的所有开发人员就会再次遭受晨后综合症.他们彼此
之间的发布行动要完全一致,因为他们必须都要使用彼此间完全相同的版本.

这还只是部分的问题.考虑一下在想要测试MyDialogs包时会发生上面.我们必须要链接进系统中所有其他的包,
包括Database包.这意味着仅仅为了测试MyDialogs就必须要做一次完整的构建.这是不可忍受的.

如果想知道为何必须要链接进这么多不同的库,以及这么多其他人的代码,只需运行一个某个类的简单的单元测
试即可,或许这是因为依赖关系图中存在环的缘故.这种环使得非常难以对模块进行隔离.单元测试和发布变得
非常困难且易于出粗.而且,在C++中,编译时间会随着模块数目成几何级数增长.

此外,如果依赖关系图中存在环,就很难确定包构建的顺序.事实上,也许就不存在恰当的顺序.对于像Java一样
要从编译过的二进制文件中读取它们的声明的语言来说,这会导致一些非常讨厌的问题.

#### 20.3.5 解除依赖环
任何情况下,都可以解除包之间的依赖环并把依赖关系图恢复为一个DAG.有两个主要的方法:
1. 使用依赖倒置原则(Dependency-Inversion Principle, DIP).针对图20.3中的情况,可以创建一个具有My-
Dialogs需要的接口的抽象基类.然后,把该抽象基类放进MyDialogs中,并使MyApplication中的类从其继承.
这就倒置了MyDialogs和MyApplication间的依赖关系,从而解除了依赖环.(参见图20.3)

请注意,我们再次从客户的角度而不是服务者的角度出发来命名接口.这是接口属于客户规则的又一次应用.

2. 新创建一个MyDialog和MyApplication都依赖的包.把MyDialog和MyApplication都依赖的类移到这个新包
中.(参见图20.4)

#### 20.3.6 抖动
第二个解决方案意味着,在需求改变面前包的结构是不稳定的.事实上,随着应用程序的增长,包的依赖关系结构
会抖动和增长.因此,必须要始终对依赖关系结构中环的情况进行监控.如果出现了环,就必须要使用某种方法把
其解除.有时这意味着要创建新的包,致使依赖关系结构增长.

#### 20.4 自顶向下设计
讨论到现在,我们可以得出一个必然的结论:不能自顶向下设计包的结构.这意味着包结构不是设计系统时首先考
虑的事情之一.事实上,包结构应该时随着系统的增长、变化而逐步演化的.

也许你会认为这是违反直觉的.我们已经认为像包这样的大粒度分解同样也是高层的功能分解.当我们看到一个
像包依赖关系结构这样的大粒度分组时,就会觉得包应该以某种方式描绘了系统的功能.然而,这可能不是包依
赖关系图的一个属性.

事实上,包的依赖关系图和描绘应用程序的功能之间几乎没有关系.相反,它们是应用程序可构建性的映射图.这
就是为何不在项目开始时设计它们的原因.在项目开始时,没有软件可构建,因此也无需构建映射图.但是,随着
实现和设计初期积累的类越来越多,对依赖关系进行管理,避免项目开发中出现晨后综合症的需要就不断增长.
此外,我们也想尽可能地保持更改的局部化,所以我们开始关注SRP和CCP,并把可能会一同变化的类放在一起.

随着应用程序的不断增长,我们开始关注创建可重用的元素.于是,就开始使用CRP来指导包的组合.最后,当环
出现时,就会使用ADP,从而包的依赖关系图会出现抖动以及增长.

如果在设计任何类之前试图去设计包的依赖关系结构,那么很可能会遭受惨败.我们对于共同封闭还没有多少了
解,也还没有察觉到任何可重用的元素.从而几乎当然会创建产生依赖环的包.所以,包的依赖关系结构是和系统
的逻辑设计一起增长和演化的.

#### 20.5 稳定依赖原则
朝着稳定的方法进行依赖.

设计不能是完全固定的.要使设计可维护,某种程度的易变性是必要的.我们通过遵循共同封闭原则(CCP)来达到
这个目标.使用这个原则,可以创建对某些变化类型敏感的包.这些包被设计成可变的.我们期望它们变化.

对于任何包而言,如果期望它是可变的,就不应该让一个难以更改的包依赖于它!否则,可变的包同样会难以更改.

你设计了一个易于更改的包,其他人只要创建一个对它的依赖就可以使它变得难以更改,这就是软件的反常特性.
没有改变你的任何模块中任何一行代码,可是它突然之间就变得难以更改了.通过遵循SDP,我们可以确保那些打
算易于更改的模块不会被那些比它们难以更改的模块所依赖.

#### 20.5.1 稳定性
把一枚硬币竖立设置,在这种状态下,它是稳定的吗?你很可能会说它不稳定.不过,除非有干扰,否则它会保持这
种状态很长一段时间.所以,稳定性和变化的频率没有直接关系.硬币的状态没有变化,但是却很难认为它是稳定
的.

韦伯斯特认为,如果某物"不容易被移动",就认为它是稳定的.稳定性和更改所需要的工作量有关.硬币不是稳定
的,因为推到它所需的工作量是非常少的.但是,桌子是非常稳定的,因为推倒它要花费相当大的努力.

这和软件有什么关系呢?使软件包难以更改的因素有许多:它的规模、复杂性、清晰程度等等.我们会忽略所有
这些因素而关注某个不同的东西.要使一个软件包难以改变,一个肯定可行的方法是让许多其他的软件包依赖于
它.具有很多输入依赖关系的包是非常稳定的,因为要使所有依赖于它的包能够相容于对它所做的所有更改,往
往需要非常大的工作量.

图20.5中展示了一个稳定的包X.有3个包依赖于它;因此,就有3个合理的理由不去更改它.我们称X对这3个包负
有责任.另外,X不依赖于任何包,因此所有的外部影响都不会使其改变.我们称X是无依赖性的.

另一方面,图20.6展示了一个非常不稳定的包.没有任何其他的包依赖于Y:我们称Y是不承担责任的.此外,Y依赖
于3个包,所以它具有3个外部更改源.我们称Y是有依赖性的.

#### 20.5.2 稳定性度量
如何度量一个包的稳定性呢?一种方法是计算进、出该包的依赖关系的数目.我们可以使用这些数值来计算该包
的位置稳定性.
1. Ca输入耦合度(Afferent Couping):指处于该包的外部并依赖于该包内的类的类的数目.
2. Cc输出耦合度(Efferent Couping):指处于该包的内部并依赖于该包外的类的类的数目.
3. (不稳定性I) I = Ce/(Ca + Ce);

该度量的取值范围是[0,1].I=0表示该包具有最大的稳定性.I=1表示该包具有最大的不稳定性.

通过计算和一个包内的类有依赖关系的包外的类的数目,就可以计算出度量Ca和Ce.考虑图20.7中的例子.

包之间的虚线箭头表示包的依赖关系.这些包的类之间的关系说明了这些依赖关系是如何形成的.其中有继承和
关联关系.

现在,我们来计算包Pc的稳定性.Pc外部有3个类依赖于Pc内的类.所以,Ca=3.此外,Pc外部有一个类被Pc内的类.
所以,Ca=3.此外,Pc外部有一个类被Pc内的类依赖.所以Ce=1,I=1/4.

在C++中,这些依赖关系一般是通过#include语句表示的.事实上,如果把源代码组织成一个源文件中只有一个类
的形式,那么计算度量I就会非常容易.在Java中,可以通过计算import语句以及类的修饰名称的数目来计算度量
I.

当一个包的I度量值为1时,就意味着没有任何其他的包依赖于该包(Ca=0);而该包却依赖于其他的包(Ce>0).这
是一个包最不稳定的状态:它是不承担责任且有依赖性的.因为没有包依赖于它,所以它就没有不改变理由,而它
所依赖的包会给它提供丰富的更改理由.

另一方面,当一个包的I度量值为0时,就意味着其他包会依赖于该包(Ca>0),但是该包却不依赖于任何其他的包
(Ce=0).它是负有责任且无依赖性的.这种包达到了最大程度的稳定性.它的依赖者使其难以更改,而且没有任何
依赖关系会迫使它去改变.

SDP规定一个包的I度量值应该大于它所依赖的包的I度量值(也就是说,I度量值应该顺着依赖的方向减少).

#### 20.5.3 并非所有的包都应该是稳定的
如果一个系统中所有的包都是最大程度稳定的,那么该系统就是不能改变的.这不是所希望的情形.事实上,我们
希望所设计出来的包结构中,一些包是不稳定的而另外一些是稳定的.图20.8中展示了一个具有3个包的系统的
理想配置.

可改变的包位于顶部并依赖于底部稳定的包.把不稳定的包放在图的顶部是一个有用的约定,因为任何向上的箭
头都意味着违反了SDP.

图20.9展示了会违反SDP的做法.我们打算让Flexible包易于更改.我们希望Flexible是不稳定的.然而,一些
工作于包Stable的开发人员,创建了一个对Flexible的依赖.这违反了SDP,因为Stable的I度量值要比Flexible
的I度量值小的多.结果,Flexible就不再易于更改了.对Flexible的更改会迫使我们去处理该更改对Stable及
其所有依赖者的影响.

要修正这个问题,我们就必须要以某种方式解除Stable对Flexible的依赖.为什么会存在这个依赖关系呢?我们
假设Flexible中有一个类C被另一个Stable中的类U使用(参加图20.10).

可以使用DIP来修改这个问题.我们创建一个接口类IU并把它放进包UInterface中.我们确保接口IU中声明了U
要使用的所有方法.接着,我们让C从这个接口继承(参见图20.11).这就解除了Stable对Flexible的依赖并促使
这两个包依赖于UInterface.UInterface非常稳定(I=0),而Flexible仍保持它必需的不稳定性(I=1).现在所
有依赖方向都是顺着I减小的方向的.

#### 20.5.4 在哪里放置高层设计?
系统中的某些软件不应该经常改变.该软件代表着系统的高层构架和设计决策.我们希望这些构架决策是稳定的.
因此,应该把封装系统高层设计的软件放进稳定的包中(I=0).不稳定的包(I=1)中应该只包含那些很可能会改变
的软件.

然而,如果把高层设计放进稳定的包中,那么体现高层设计的源代码就会难以更改.这会使设计变得不灵活.怎样
才能让一个具有最高稳定性(I=0)的包足够的灵活,可以经受得住变化呢?在OCP中可以找到答案.OCP原则告诉我
门,那些足够灵活可以无需修改即可拓展得类是存在的,并且是所希望的.哪种类符合OCP原则呢?抽象类.

#### 20.6 稳定抽象原则
包的抽象程度应该和其稳定程度一致.

该原则把包的稳定性和抽象性联系起来.它规定,一个稳定的包应该也是抽象的.这样它的稳定性就不会使其无法
拓展.另一方面,它规定,一个不稳定的包应该是具体的,因为它的不稳定性使其内部的具体代码易于更改.

因此,如果一个包是稳定的,那么它应该也要包含一些抽象类,这样就可以对它进行扩展.可扩展的稳定包是灵活
的,并且不会过分限制设计.

SAP和SDP结合在一起形成了针对包的DIP原则.这样说是准确的,因为SDP规定依赖应该朝着稳定的方向进行,而
SAP则规定稳定性意味着抽象性.因此,依赖应该朝着抽象的方向进行.

然而,DIP是一个处理类的原则.类没有灰度的概念(the shades of grey).一个类要么是抽象的,要么不是.SDP
和SAP的结合是处理包的,并且允许一个包是部分抽象、部分稳定的.

#### 20.6.1 抽象性度量
A是一个测量包抽象程度的度量标准.它的值就是包中抽象类的数目和全部类的数目的比值.A=Na/Nc.

Nc--包中类的总数  
Na--包中抽象类的数目.请记住,一个抽象类是一个至少具有一个纯接口(pure interface)的类,并且它不能被
实例化.  
A--抽象性.

度量A的取值范围是从0到1.0意味着包中没有任何抽象类,1意味着包中只包含抽象类.

#### 20.6.2 主序列
现在,我们来定义稳定性(I)和抽象性(A)之间的关系.我们可以创建一个以A为纵轴.I为横轴的坐标图.
