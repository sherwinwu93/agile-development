### 第20章 包的设计原则
随着程序规模和复杂度增加,需要更高层次对它们进行组织.类对于小型程序来说是非常方便的组织单元,对于
大型程序,如果仅仅使用类,会显得粒度过细.因此,就需要比类大的东西来辅助大型程序的组织.

6个原则.前3个关注内聚性,指导我们对类组包.后3个关注耦合性,帮助我们确定包的相互关系.最后两个原则描
述 依赖性管理度量,据此对设计的依赖结构进行度量和刻画.
#### 20.1 如何进行包的设计
在UML的概念中,包可以用作包容一组类的容器.通过把类组织成包,我们可以在更高层次的抽象上来理解设计.我
们也可以通过包来管理软件的开发和发布.目的就是根据一些原则对程序中的类进行划分,然后把那些划分后的
类分配到包中.

但是类经常会和其他类之间存在依赖关系.这些依赖关系还经常会跨越包的边界.因此,包之间也会产生依赖关系
.包之间的依赖关系展现了程序的高层组织结构,我们应该对这些关系进行管理.

这提出了很多问题:  
1. 在向包中分配类时应该依据什么原则?
2. 应该使用什么设计原则来管理包之间的关系?
3. 包的设计应该先于类呢(自顶向下)?还是类的设计应该先于包(自底向上)?
4. 如何实际表现出"包"?在C++中如何表现?在Java中如何表现?在某种开发环境中又如何表现?
5. 包创建好后,我们应当将它们用于何种目的?

本章讲诉6个设计原则,涉及包的创建、相互关系的管理以及包的使用.前3个原则是用来指导如何把类划分到
包中.后3个原则是用来处理包之间的相互关系的.

#### 20.2 粒度:包的内聚性原则
这里要讲诉的3个关于包的内聚性原则,可以帮助开发者决定如何把类划分到包中.这些原则依赖于这样的事实:
至少已经存在一些类,并且它们之间的相互关系也已经确定.因此,这些原则是根据"自底向上"的观点对类进行
划分的.
#### 20.2.1 重用发布等价原则(REP)
重用的粒度就是发布的粒度.


当你重用一个库类时,对这个类库的作者有什么期望呢?你当然想得到好的文档,可以工作的代码,规格清晰的
接口等待.但是.你还会有其他的期望.

首先,你希望代码的作者能保证为你维护这些代码,只有这样才值得你在重用这些代码上花费时间.毕竟.如果
需要你亲自去维护这些代码,那将会花费你大量的时间,这些时间也许可以自己用来设计一个小些但是好些的
包.

其次,你希望代码的作者在计划对代码的接口和功能进行任何改变时,提前通知你一下.但是仅仅通知一下是
不够的.代码的作者必须尊重你拒绝使用任何新版本的权力.否则.当你处在开发进度中的一个关键时刻时,
他可能发布了一个新的版本,或者他对代码进行了改变,之后就干脆在也无法与你的系统兼容了.

无论在哪种情况下.如果你决定不接纳新版本,作者必须保证对于你所使用的旧版本继续提供一段时间的支持.
这段时间也许只有3个月.或者长达1年.你们两个人之间必须就这些事情进行协商.但是,他不能够和你断绝
关系并且拒绝对你提供支持.如果他不同意对你使用的稍旧一点的版本提供支持,那么你就应该认真的考虑
一下是否情愿忍受对方反复无常的变化,而继续使用他的代码.

这个问题主要是行政问题.如果有其他的人将要重用代码,就必须要进行行政和支持方面的工作.但是这些行
政的问题对于包结构具有深刻的影响.为了给重用者提供所需的保证,代码的作者必须把它们的软件组织到
一个可重用的包中,并且通过版本号对那些包进行跟踪.

REP指出,一个包的重用粒度可以和发布粒度一样大.我们所重用的任何东西都必须同时被发布和跟踪.简单
的编写一个类.然后声称它是可重用的做法是不现实的.只有在建立一个跟踪系统.为潜在的使用者提供所需
要的变更通知,安全性以及支持后,重用才有可能.

REP带给我们了关于如何把设计划分到包中的第一个提示.由于重用性必须是基于包,所以可重用的包必须包
含可重用的类.因此,至少,某些包应该由一组可重用的类组成.

行政上的约束力将会影响到对于软件的划分,这看上去令人不安,但是软件不是一个可以依赖纯数字规则组织
起来的纯数学实体.软件是一个人的智力活动的产品.软件由人创建并被人使用,并且如果我们将要对软件进
行重用.那么它肯定以一种人认为方便重用的方式进行划分.

那么,关于包的内部结构方法,我们学到了什么呢?我们必须从潜在的重用者的角度去考虑包的内容.如果一个
包中的软件是用来重用的.那么它就不能再包含不是为了重用目的而设计的软件.一个包中的软件要么是可
重用的,要么都不是可重用的.

可重用性不是唯一的标准,我们也要考虑重用这些软件的人.当然,一个容器类库是可重用的,一个金融方面的
框架也是可重用的.但是,我们不希望把它们放到同一个包中.很多希望重用容器类库的人可能对于金融框架
根本不感兴趣.因此,我们希望一个包中的所有类对于同一类用户来说都是可重用的.我们不希望一个用户包
中所包含的类中,一些是他所需要的.另一些对他却完全不适合.

#### 20.2.2 共同重用原则(CRP)
一个包中的所有类应该是共同重用的.如果重用了包中的一个类,那么就要重用包中的所有类.


这些原则可以帮助我们决定哪些类应该放在同一个包中.它规定了趋向于共同重用的类应该属于同一个包.

类很少会孤立的重用.一般来说,可重用的类需要与作为该可重用抽象一部分的其他类协作.CRP规定了这些
类应该属于同一个包.在这样的一个包中,我们会看到类之间有很多的互相依赖.

一个简单的例子是容器类以及与它管理的迭代器类.这些类彼此之间紧密耦合在一起,因此必须共同重用.所
以它们应该在同一个包中.

但是,CRP告诉我们的不仅仅是什么类应该共同放入一个包中.它还告诉我们什么类不应该放入同一个包中.
当一个包使用了另一个包时,它们之间会存在一个依赖关系.也许一个包仅仅使用了另外一个包中的一个类.
然而,那根本不会削弱这两个包之间的依赖关系.使用者依然依赖于被使用的包.每当被使用的包发布时,使
用者包必须要进行重新验证和重新发布.即使发布的原因仅仅是由于更改了一个使用者包根本不关心的类,
也必须要这样做.

此外,包也经常以共享库,jar等物理表现得形式出现.如果被使用的包以JAR的形式发布,那么使用这个包的
代码就依赖于整个JAR.对JAR的任何修改--即使所修改的是与用户代码无关的类,仍然会造成这个JAR的一个
新版本的发布.这个JAR仍然要重新发布,并且使用这个JAR的代码也要进行重新验证.

因此.我想确信当我依赖于一个包时,我将依赖于那个包中的每一个类.换句话说,我想确信我放入一个包中的
所有类是不可分开的,仅仅依赖于其中一部分的情况是不可能的,否则,我将要进行不必要的重新验证和重新
发行,并且会白费相当数量的努力.

因此,CRP告诉我们更多的是,什么类不应该放在一起.CRP规定相互之间没有紧密联系的类不应该在同一个包
中.

#### 20.2.3 共同封闭原则(CCP)
包中的所有类对于同一类性质的变化应该是共同封闭的.一个变化若对一个包产生影响,则将对该包中的所有
类产生影响,而对于其他的包不造成任何影响.

这是单一职责原则对于包的重新规定.正如SRP规定的一个类不应该包含多个引起变化的原因那样,这条原则
规定了一个包不应该包含多个引起变化的原因.

在大多数的应用中,可维护性的重要性是超过可重用性的.如果一个应用中的代码必须更改,那么我们宁愿都
集中在一个包中,而不是分布在多个包中.如果更改集中在一个单一的包中,那么我们仅仅需要发布那一个
更改了的包.不依赖那个更改了的包的其他包则不需要重新验证或者重新发布.

CCP鼓励我们把可能由于同样的原因而更改的所有类共同聚集在同一个地方.如果两个类之间有非常紧密的
绑定关系.不管是物理上的还是概念上的,那么它们总是会一同进行变化,因而它们应该属于同一个包中.这样
会减少软件的发布、重新验证、重新发布的工作量.

这个原则和开放封闭原则OCP密切相关.本原则中"封闭"这个词和OCP中的具有同样的含意.OCP规定了类对
于修改应该是封闭.对于扩展应该是开放的.但是正如我们所学到的,100%的封闭是不可能做到的.应当进行
有策略的封闭.我们所设计的系统应该对于我们经历过的最常见的变化做到封闭.

CCP通过把对于一些确定的变化类型开饭的类共同组织到同一个包中,从而增强了上述内容.因而,当需求中
的一个变化到来时,那个变化就会很有可能被限制在最小数量的包中.

#### 20.2.4 包内聚性总结
过去,我们对内聚性的认识要远比上面3个原则所蕴含的简单.我们习惯于认为内聚性不过是指一个模块执行
一项并且仅仅一项功能.然而,这3个关于包内聚性的原则描述了有关内聚性的更加丰富的变化.在选择要共
同组织到包中的类时,必须要考虑可重用性于可开发性之间的相反作用力.在这些作用力和应用的需要之间
进行平衡不是一件简单的工作.此外,这个平衡几乎总是动态的.也就是说,今天看起来合适的划分到了明年
也许就不再合适了.因此,当项目的重心从可开发新向可重用性转变时,包的组成很可能会变动并随时间而演
化.

#### 20.3 稳定性:包的耦合性原则
接下来的3个原则用来处理包之间的关系.这里,我们会再次碰到可开放性和逻辑设计之间的冲突力.来自技
术和行政方面的作用力都会影响到包的组织结构.并且这种作用力还是易变的.

#### 20.3.1 无环依赖原则
在包的依赖关系图中不允许存在环
你曾经有过这样的经历吗?工作了一整天,终于完成了某项功能后回家,不料第二天早晨一来却发现那项功能
不再工作了.原因是什么呢?因为有人比你走的更晚,并且更改了你所依赖的某些东西!我称其为"晨后综合症"

如果开发环境中存在有许多开发人员都在更改相同的源代码文件集合的情况,那么就会发生晨后综合症.在
仅有几个开发人员的相对小的项目中,这不是一个大问题.但是当项目和开发团队的规模增长时,晨后综合症
就会带来可怕的噩梦.在缺乏纪律的团队中,几周都无法构建出一个稳定的项目版本的情况是很常见的.相反,
每个人都忙于一遍遍地更改他们的代码,试图使之能够相容于其他人所做的最近更改.

近几十年来,逐步形成了两个针对该问题的解决方案.这两个方案都来自电信业.第一个是"每周构建",第二
个是ADP.