### 第20章 包的设计原则
随着程序规模和复杂度增加,需要更高层次对它们进行组织.类对于小型程序来说是非常方便的组织单元,对于
大型程序,如果仅仅使用类,会显得粒度过细.因此,就需要比类大的东西来辅助大型程序的组织.

6个原则.前3个关注内聚性,指导我们对类组包.后3个关注耦合性,帮助我们确定包的相互关系.最后两个原则描
述 依赖性管理度量,据此对设计的依赖结构进行度量和刻画.
#### 20.1 如何进行包的设计
在UML的概念中,包可以用作包容一组类的容器.通过把类组织成包,我们可以在更高层次的抽象上来理解设计.我
们也可以通过包来管理软件的开发和发布.目的就是根据一些原则对程序中的类进行划分,然后把那些划分后的
类分配到包中.

但是类经常会和其他类之间存在依赖关系.这些依赖关系还经常会跨越包的边界.因此,包之间也会产生依赖关系
.包之间的依赖关系展现了程序的高层组织结构,我们应该对这些关系进行管理.

这提出了很多问题:  
1. 在向包中分配类时应该依据什么原则?
2. 应该使用什么设计原则来管理包之间的关系?
3. 包的设计应该先于类呢(自顶向下)?还是类的设计应该先于包(自底向上)?
4. 如何实际表现出"包"?在C++中如何表现?在Java中如何表现?在某种开发环境中又如何表现?
5. 包创建好后,我们应当将它们用于何种目的?

本章讲诉6个设计原则,涉及包的创建、相互关系的管理以及包的使用.前3个原则是用来指导如何把类划分到
包中.后3个原则是用来处理包之间的相互关系的.

#### 20.2 粒度:包的内聚性原则
这里要讲诉的3个关于包的内聚性原则,可以帮助开发者决定如何把类划分到包中.这些原则依赖于这样的事实:
至少已经存在一些类,并且它们之间的相互关系也已经确定.因此,这些原则是根据"自底向上"的观点对类进行
划分的.
#### 20.2.1 重用发布等价原则(REP)
重用的粒度就是发布的粒度.


当你重用一个库类时,对这个类库的作者有什么期望呢?你当然想得到好的文档,可以工作的代码,规格清晰的
接口等待.但是.你还会有其他的期望.

首先,你希望代码的作者能保证为你维护这些代码,只有这样才值得你在重用这些代码上花费时间.毕竟.如果
需要你亲自去维护这些代码,那将会花费你大量的时间,这些时间也许可以自己用来设计一个小些但是好些的
包.

其次,你希望代码的作者在计划对代码的接口和功能进行任何改变时,提前通知你一下.但是仅仅通知一下是
不够的.代码的作者必须尊重你拒绝使用任何新版本的权力.否则.当你处在开发进度中的一个关键时刻时,
他可能发布了一个新的版本,或者他对代码进行了改变,之后就干脆在也无法与你的系统兼容了.

无论在哪种情况下.如果你决定不接纳新版本,作者必须保证对于你所使用的旧版本继续提供一段时间的支持.
这段时间也许只有3个月.或者长达1年.你们两个人之间必须就这些事情进行协商.但是,他不能够和你断绝
关系并且拒绝对你提供支持.如果他不同意对你使用的稍旧一点的版本提供支持,那么你就应该认真的考虑
一下是否情愿忍受对方反复无常的变化,而继续使用他的代码.

这个问题主要是行政问题.如果有其他的人将要重用代码,就必须要进行行政和支持方面的工作.但是这些行
政的问题对于包结构具有深刻的影响.为了给重用者提供所需的保证,代码的作者必须把它们的软件组织到
一个可重用的包中,并且通过版本号对那些包进行跟踪.

REP指出,一个包的重用粒度可以和发布粒度一样大.我们所重用的任何东西都必须同时被发布和跟踪.简单
的编写一个类.然后声称它是可重用的做法是不现实的.只有在建立一个跟踪系统.为潜在的使用者提供所需
要的变更通知,安全性以及支持后,重用才有可能.

REP带给我们了关于如何把设计划分到包中的第一个提示.由于重用性必须是基于包,所以可重用的包必须包
含可重用的类.因此,至少,某些包应该由一组可重用的类组成.

行政上的约束力将会影响到对于软件的划分,这看上去令人不安,但是软件不是一个可以依赖纯数字规则组织
起来的纯数学实体.软件是一个人的智力活动的产品.软件由人创建并被人使用,并且如果我们将要对软件进
行重用.那么它肯定以一种人认为方便重用的方式进行划分.

那么,关于包的内部结构方法,我们学到了什么呢?我们必须从潜在的重用者的角度去考虑包的内容.如果一个
包中的软件是用来重用的.那么它就不能再包含不是为了重用目的而设计的软件.一个包中的软件要么是可
重用的,要么都不是可重用的.

可重用性不是唯一的标准,我们也要考虑重用这些软件的人.当然,一个容器类库是可重用的,一个金融方面的
框架也是可重用的.但是,我们不希望把它们放到同一个包中.很多希望重用容器类库的人可能对于金融框架
根本不感兴趣.因此,我们希望一个包中的所有类对于同一类用户来说都是可重用的.我们不希望一个用户包
中所包含的类中,一些是他所需要的.另一些对他却完全不适合.

#### 20.2.2 共同重用原则(CRP)
一个包中的所有类应该是共同重用的.如果重用了包中的一个类,那么就要重用包中的所有类.


这些原则可以帮助我们决定哪些类应该放在同一个包中.它规定了趋向于共同重用的类应该属于同一个包.

类很少会孤立的重用.一般来说,可重用的类需要与作为该可重用抽象一部分的其他类协作.CRP规定了这些
类应该属于同一个包.在这样的一个包中,我们会看到类之间有很多的互相依赖.

一个简单的例子是容器类以及与它管理的迭代器类.这些类彼此之间紧密耦合在一起,因此必须共同重用.所
以它们应该在同一个包中.

但是,CRP告诉我们的不仅仅是什么类应该共同放入一个包中.它还告诉我们什么类不应该放入同一个包中.
当一个包使用了另一个包时,它们之间会存在一个依赖关系.也许一个包仅仅使用了另外一个包中的一个类.
然而,那根本不会削弱这两个包之间的依赖关系.使用者依然依赖于被使用的包.每当被使用的包发布时,使
用者包必须要进行重新验证和重新发布.即使发布的原因仅仅是由于更改了一个使用者包根本不关心的类,
也必须要这样做.

此外,包也经常以共享库,jar等物理表现得形式出现.如果被使用的包以JAR的形式发布,那么使用这个包的
代码就依赖于整个JAR.对JAR的任何修改--即使所修改的是与用户代码无关的类,仍然会造成这个JAR的一个
新版本的发布.这个JAR仍然要重新发布,并且使用这个JAR的代码也要进行重新验证.

因此.我想确信当我依赖于一个包时,我将依赖于那个包中的每一个类.换句话说,我想确信我放入一个包中的
所有类是不可分开的,仅仅依赖于其中一部分的情况是不可能的,否则,我将要进行不必要的重新验证和重新
发行,并且会白费相当数量的努力.

因此,CRP告诉我们更多的是,什么类不应该放在一起.CRP规定相互之间没有紧密联系的类不应该在同一个包
中.